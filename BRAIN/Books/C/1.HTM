<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>COMPLETE C</title>
<style>
<link href="../style.css" rel=stylesheet type=text/css>{  }
 li.MsoNormal
	{mso-style-parent:"";
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman";
	margin-left:0in; margin-right:0in; margin-top:0in}
-->
</style>
</head>

<body>

<table width="838" border="1" align="center" style="border-width: 0" height="1714">
  <tr> 
    <td bordercolor="0" style="border-style: none; border-width: medium" width="10" bgcolor="#33CCFF" height="55">&nbsp;</td>
    <td bordercolor="0" style="border-style: none; border-width: medium" width="814" bgcolor="#33CCFF" colspan="2" height="55">
    <b><font face="Broadway BT" size="7">COMPLETE C</font></b><font face="Broadway BT" size="7" color="#000000"><b> </b></font></td>
  </tr>
  <tr> 
    <td bordercolor="0" style="border-style: none; border-width: medium" width="832" colspan="3" bgcolor="#009900" height="13">&nbsp;</td>
  </tr>
  <tr>
    <td style="border-style: none; border-width: medium" width="9" bgcolor="#00CC99" height="17">&nbsp;</td>
    <td style="border-style: none; border-width: medium" width="795" bgcolor="#00CC99" height="17">
    &nbsp;</td>
    <td style="border-style: none; border-width: medium" width="14" height="17" bgcolor="#00CC99">&nbsp;</td>
  </tr>
  <tr>
    <td style="border-style: none; border-width: medium" width="9" height="11" bgcolor="#FFCC00">&nbsp;</td>
    <td style="border-style: none; border-width: medium" width="795" height="11" bgcolor="#FFCC00">
    INTRODUCTION</td>
    <td style="border-style: none; border-width: medium" width="14" height="11" bgcolor="#FFCC00">&nbsp;</td>
  </tr>
  <tr>
    <td style="border-style: none; border-width: medium" width="9" height="116" bgcolor="#FFFFCC">&nbsp;</td>
    <td style="border-style: none; border-width: medium" width="795" height="116" bgcolor="#FFFFCC">
<font size="6">COMPLETE&nbsp; C</font><p><font size="6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</font><font size="4">C The worlds most popular language is still the toppest 
language when it comes to serious programming whether in web based(cgi) or in 
case of stand alone client applications or operating systems only a detailed 
understanding of c will help us to know the reason of the success of this 
language so lets go through it</font><br>
<font color="#800000">The 'C' language was developed at the AT&amp;T Bell Laboratories, USA by Dennis 
Ritchie in 1972 on a DEC PDP-II machine. This language is derived from an another 
language called B developed by Ken Thompson of Bell Laboratories in 1970 which 
is devCGeloped from the language BCPL (Basic Combined Programming Language) developed 
by Martin Richard of Cambridge University in 1967 which is derived from the language 
CPL (Combined Programming Language) developed by Cambridge University and the 
University of London in 1963 and it is developed from the lan-guage called ALGOL 
(Algorithmic Language) developed by an International Commit-tee in the year 1960.<br>
The 'C' Language was originally developed for programming under UNIX Operating 
system, which was developed by Ken Thompson and Dennis Ritchie. After develop-ing 
'C' almost 90% of UNIX operating system is rewritten in C from assembly lan-guage. 
Therefore UNIX and C have a close relationship.<br>
'C' gives the programmer what he wants, i.e., few restrictions, block structures, 
standard functions, a compact set of keywords and rich set of data structures.<br>
For many years 'C' has no standard. i.e. Every manufacture developed their style 
of 'C' compilers. In 1983 the American National Standards Institute (ANSI) established 
a committee named X3J11 created a standard for the 'C' language. The standard 
includes the character-set, keywords, compiler environment and the function library 
etc.<br>
C is a structured language, which uses the compartmentalisation; i.e. A program 
is broken into different modules, each of which is used for a single specific 
task. This is supported in 'C' by the use of functions. Basically a 'C' program 
is a collection of one or more functions.<br>
'C' language also supports the programming structures like sequence, selection 
and iteration/looping. However the goto statements are not encouraged in structured 
programming, 'C' supports it too.<br>
Even though 'C' is a high level language it is often called a middle-level language 
because it combines the elements of high level language, like structured program-ming, 
modular programming etc. with the functionalism of the assembly language like 
direct manipulation of bits, bytes, memory addressees with the help of pointers.<br>
'C' is a flexible, general-purpose language. i.e. The capability of manipulating 
bits, bytes, memory address makes it well suited for systems programming and the 
high-level components makes it suitable for application packages. 'C' is used 
for writing operating systems like UNIX and MS-DOS and the compilers and interpreters 
for BASIC, FORTRAN, Pascal, LISP, LOGO etc. Popular application packages like 
dBase, Lotus 1-2-3 and CLIPPER are also written in 'C'.<br>
'C' language is machine independent and it is a highly portable language. Portable 
means that 'C' programs written for one computer/operating system can be run on 
another with little or no modification. All high-level languages are portable. 
'C' is considered to be highly portable because the machine dependent parts in 
'C' com-pilers are written in 'C'.<br>
Turbo C compiler is an integrated package. It includes an editor, compiler, linker 
and loader. Every 'C' program file is identified using the &#8216;.C&#8217; extension. 
The source code written using the editor is first passed through the C pre-processor. 
The pre-processor is a program that modifies the source code according to directives 
sup-plied in the program. The Pre-processor Directives begin with the # symbol. 
They must start in the first column and they are usually placed at the beginning 
of a pro-gram. The pre-processor expands the directives and it&#8217;s output, 
the expanded source code is fed to the 'C' compiler. The compiler translates the 
source code into the assembly language. The system assembler produces the object 
code (.obj). This object code has to be linked with support routines from the 
'C' run-time library to obtain the final executable code (.exe). The systems loader 
can run the executable code.<br>
'C' Language has no input/output operations. The compiler compiles a language 
of functions, all input and output is done with functions. Because of this feature, 
a standard library gives 'C' its most endearing feature is portability.<br>
Every function must be defined before it can be used in the program. Every function 
definition has two parts, a function header and a body that follows it. The header 
defines the function&#8217;s name and the arguments. The headers of the library 
functions are stored in header files with extension .h. So these must be included 
before the library functions are used in a 'C' program.<br>
Using the Turbo C Compiler<br>
Type tc at the DOS prompt and press ENTER key. The Turbo C integrated environ-ment 
displays on the screen. You can use the menu options like save, open, create a 
new file etc. from the main menu strip which is at the top most line of the screen.<br>
After typing the program you can save it by pressing the F2 key or File?Save com-mand. 
If necessary give the filename. To execute the program press Ctrl+F9 key combination. 
The progress window on the screen will show each phase in the crea-tion of the 
executable file. If there are no errors, the screen will be cleared and the program 
will start running. After the program is executed, you will get back to the Turbo 
C environment automatically. You can view the user screen by pressing the Alt+F5 
key combination. To return to the Turbo C environment strike any key.<br>
If there are any errors in the program, the messages along with the line numbers 
will be displayed in a separate message window at the bottom of the screen. Pressing 
the F6 key can make corrections, which place the cursor in the Edit window. After 
making corrections save it again and run. <br>
You can activate the main menu by pressing the F10 key and then use the arrow 
keys. You can quit the Turbo C integrated environment by pressing Alt+X key com-bination.<br>
Programming Conventions <br>
&#8216;C&#8217; is a freestyle language i.e., no restriction on program writing. 
Statements can start and end at any column. You can include spaces, tabs and blank 
lines in a program to improve readability.<br>
A &#8216;C&#8217; statement is called an expression statement, which is terminated 
by a semico-lon. They are not restricted to one line, can extend to many lines 
and multiple state-ments separated by semicolons can be written in a single line. 
&#8216;C&#8217; is a case-sensitive language. The programs are written in lower 
case, with some words capitalised.<br>
&#8216;C&#8217; language implements the concept of structured programming through 
code blocks. A code block is a logically connected group of program statements 
that is treated as a unit. A code block is created by placing the sequence of 
statements between curly brackets ({and}) called braces.<br>
A &#8216;C&#8217; program consists of one or more functions and one of they must 
be called main(). The main() is the first function executed in the program, but 
not necessarily the first function. The statements of a function are enclosed 
in a code block may contain additional nested blocks and each block keeps their 
variables as local.<br>
Header files with extension .h can be included using the include statement.<br>
e.g.:- # include &lt;stdio.h&gt; <br>
The header filename should be enclosed within angle brackets (&lt; and &gt;).<br>
The &#8216;C&#8217; Character Set<br>
A valid &#8216;C&#8217; program consists of characters from the following character 
set:<br>
Description Characters<br>
Alphabetic characters a, b, c,&#8230;&#8230;&#8230;&#8230;, z<br>
A, B, C,&#8230;&#8230;&#8230;..., Z<br>
Digits 0, 1, 2,&#8230;&#8230;.., 8, 9<br>
Special Characters Space &#8216; , ; _ + - * / &#8220; { } [ ]<br>
( ) ? &gt; &lt; = ! ~ &amp; % # : \ ^ .<br>
Program statements in &#8216;C&#8217; can use 92 out of 95 printable characters 
(all printable ASCII characters except ASCII 36 ($), ASCII 64 (@) and ASCII (`). 
Data and stings within a program can also include any other characters.<br>
Keywords<br>
Keywords are words that are part of the &#8216;C&#8217; language and they are 
recognised by &#8216;C&#8217; as having specific meaning in specific contexts. 
Such words are cannot be used as variable/function/constant name in &#8216;C&#8217;. 
Keywords are in lowercase only. The ANSI standard &#8216;C&#8217; has 32 keywords 
are in lowercase only. The ANSI standard C has 32 Keywords 27 of the keywords 
are defined by Dennis Ritchie and 5 by ANSI. Addi-tional keywords are defined 
in different versions.<br>
auto break case char continue default<br>
do double else extern float for<br>
for goto if int long register<br>
return short sizeof static struct switch<br>
typedef union unsigned while const enum<br>
signed void volatile <br>
Identifiers<br>
Identifiers are names, which the user assigns within a &#8216;C&#8217; program 
to variables, arrays constants or functions. The identifier name can include any 
alphabet (a-z, A-Z) digits and underscore. The first letter must be an alphabet 
and a maximum of 32 characters. </font></p>
<p><font color="#800000">Data Types<br>
  A Data type defines a set of values that a variable can store along with a set 
  of operations that can be performed on that variable.<br>
  &#8216;C&#8217; supports four fundamental data types i.e. Integer (int), Character 
  (char) Floating point (float) and Double precision floating point (double) and 
  two additional void and enum.<br>
  &#8216;C&#8217; also allows using the qualifiers to extend the accuracy of integers 
  and floating points. But qualifiers will consume more memory. The qualifiers 
  are short, long, signed and unsigned. Then it is called derived data type.<br>
  Char Type: Used to store a single character of information. Char constant must 
  be enclosed between two single quotation marks. i.e. &#8220;a&#8221; is not 
  allowed but &#8216;a&#8217; is al-lowed. C allows the qualifiers signed and 
  unsigned with Char type.<br>
  Int Type: Integer type variables can only contain whole number. i.e. They can&#8217;t 
  store decimal point or fractional part. int type can be qualified using long, 
  short, signed and unsigned. e.g.:- 10, -23<br>
  Float type: Floating point numbers are numbers that can have a decimal point 
  and fractional part. They also called real numbers. Also floating point variable 
  can hold more digits than integer type. This type gives a precision of 6 digits. 
  But floating-point calculations are slower in execution and occupy more memory 
  than integer type. e.g.:- 10.199999, 5.54567, -23.465371 Floating point variables 
  can also store num-bers in scientific notation. e.g.: 123.45e6 for 123.45 x 
  106.<br>
  Double Type: If the accuracy provided by float type is not sufficient, the double 
  precision floating point type. i.e., Double type can be used. Double type gives 
  an accuracy of 16 digits. They can also store numbers in scientific notation. 
  To get an extended double precision use long qualifier with double.</font></p>
<p><br>
  Size and Range of Data Types<br>
  Data type Size Range<br>
  Char/ Signed Char 1 -128 to +127<br>
  Unsigned Char 1 0 to 255<br>
  Int/ Signed Int 2 -32768 to +32767<br>
  Unsigned Int 2 0 to 65535<br>
  Signed Short Int 1 -128 to +127<br>
  Unsigned Short Int 1 0 to 255<br>
  Long Int/ Signed long int 4 -214,83,74,648 to +214,83,74,647<br>
  Unsigned long int 4 0 to 429,67,49,295<br>
  Float 4 -3.4e38 to +3.4e38<br>
  Double 8 -1.7e308 to +1.7e308<br>
  Long double 10 -3.4e4932 to +1.1e4932</p>
<p>Variable Declaration</p>
<p><br>
  &#8216;C&#8217; requires that any identifier including variables be declared 
  before it appears in an executable statement. The variable declaration statements 
  must be the first state-ments in a code-block. Declaration tells the compiler, 
  the name of the variable and the data type of that variable. In &#8216;C&#8217; 
  preceding the variable name with the data type followed by a space does a variable 
  declaration.<br>
  syntax: datatype variable_name;<br>
  e.g.:- int age; float result; etc.<br>
  You can declare all the variables of same type in one declaration statement.<br>
  e.g.:- int x, y, z, age;<br>
  Declaration that creates an initial value is termed as definition.<br>
  e.g.:- int x = 0, y = 0; char = &#8216;y&#8217;; etc.,<br>
  ARRAYS<br>
  An array is a group of related data items allocated consecutively in memory 
  that share a common name. The individual data items in an array are called elements 
  and are addressed by the array name and the element&#8217;s index number or 
  subscript in square brackets ([ and ]). Arrays can be of any data type and have 
  up to 7 dimen-sions. The dimensions may vary depending on the compiler. Arrays 
  must be de-clared before they are used. The number of elements in each dimension 
  must be declared in square brackets.<br>
  syntax : datatype variable_name[ size ]<br>
  where size is the number of elements in the array. <br>
  e.g.:- int age[10]; float results[12]; int marks[10][5]; etc.<br>
  In &#8216;C&#8217; array subscript starts from 0 to arraysize-1. Each array 
  element can be used as like the normal variable in any operation. Array elements 
  can be assigned values at anywhere in the program using the equal to (=) symbol. 
  <br>
  e.g.:- marks[5][2]=10; age[0]=21; etc.<br>
  Arrays can be initialised at the time of declaration with a list of values enclosed 
  in braces. For example,<br>
  int age[3] = {1,2,3}; int table[2][3]={ 1,2,3,4,5,6};<br>
  int table[2][3]={ {1,2,3},{4,5,6}}; <br>
  int table[2][3]= {<br>
  {1,2,3},<br>
  {4,5,6}<br>
  }; etc.<br>
  Strings<br>
  In &#8216;C&#8217;, a string is an array of characters terminated by a NULL 
  character. Any charac-ter(s) enclosed in double quotation marks are a string 
  constant.<br>
  e.g.:- &#8220;Hello everybody&#8221;, &#8220;a&#8221; etc.<br>
  A string is stored as an array of characters with a NULL character (ASCII value 
  0) represented by the character &#8216;\0&#8217; at the end.<br>
  e.g.:- <br>
  &#8216;H&#8217; &#8216;E&#8217; &#8216;L&#8217; &#8216;L&#8217; &#8216;O&#8217;	
  &#8216;\0&#8217;<br>
  Therefore the array size should be equal to the maximum number of characters 
  in the string plus 1.<br>
  syntax : char array_name[size]<br>
  e.g.:- char name[25]; names[12][25]; etc.<br>
  Character arrays can initialise when they are declared.<br>
  e.g.:- char name[8] = &#8220;computer&#8221;;<br>
  char name[8] = {&#8216;c&#8217;, &#8217;o’, ’m, &#8217;p&#8217;, 
  &#8217;u&#8217;, &#8217;t&#8217;, &#8217;e&#8217;,r, &#8216;\0&#8217;};<br>
  String can initialise without giving the array size. Then &#8216;C&#8217; compiler 
  automatically determined the array size based on the initialising string.<br>
  e.g.:- char name[] = &#8220;computer&#8221;;<br>
  After declaring the string variable you can&#8217;t assign a new value to the 
  sting variable using the assignment operator (=). To do this you should use 
  the library function strcpy.<br>
  Syntax : strcpy(destination, Source);<br>
  The source can be a string variable or a string constant and the destination 
  must be a string variable.<br>
  INPUT AND OUTPUT IN 'C'<br>
  'C' does not have any built in input/output statements as part of its syntax. 
  All I/O operations are carries out through function calls from the standard 
  I/O library. 'C' compiler treats all devices as files like standard input (stdin), 
  the keyboard, standard output (stdout), the monitor and standard error (stderr) 
  also the monitor. There are two different types of I/O operations. They are 
  buffered I/O and unbuffered I/O. Buffer is a temporary storage area.<br>
  UNBUFFERED I/O: In unbuffered I/O, characters typed at the keyboard is made 
  available to the program immediately without being stored temporarily in buffer 
  area and it is not necessary to press the ENTER key to complete. This type of 
  I/O is used in interactive programs where the processing must be executed without 
  waiting the ENTER key press. <br>
  getch() <br>
  syntax : int getch(void);<br>
  Accepts a single character from the standard input device (Usually the keyboard). 
  This function does not waits until the user types the ENTER key and does not 
  ech-oes the user pressed character. It returns the integer value of the character.<br>
  e.g.:- int a;<br>
  a = getch();<br>
  printf(&quot;%d - - %c&quot;, a, a);<br>
  putch()<br>
  syntax : int putch(int argument);<br>
  Outputs a single character on the screen, at the cursor position. The argument 
  may be a single character constant, character variable, integer or a function 
  returning a char type value.<br>
  e.g.:- putch(a);<br>
  putch(65);<br>
  putch(getch());<br>
  getche()<br>
  syntax : int getche(void);<br>
  Accepts a single character from the keyboard. This also does not wait for the 
  ENTER key but it echoes the entered character on the cursor position. getche() 
  returns the integer value of the user pressed character.<br>
  e.g.:- getche();<br>
  a = getche();<br>
  putch(getche());<br>
  BUFFERED I/O: In buffered I/O, characters typed at the keyboard are collected 
  until the user presses the ENTER key. Then the typed characters are made available 
  to the program as a block. In the event that mistakes are made and the ENTER 
  key is not pressed, the mistakes can be corrected where this is not possible 
  in unbuffered I/O.<br>
  getchar() <br>
  syntax : int getchar(void);<br>
  Accepts a single character from the keyboard. This function waits until the 
  ENTER key is pressed. It also return an integer value between 0 - 255.<br>
  e.g.:- x = getchar();<br>
  getchar();<br>
  putchar()<br>
  syntax : int putchar(int argument);<br>
  Displays a character on the screen at the cursor position. Argument can be a 
  single character constant enclosed within single quotes, a character variable, 
  an integer or a function returning char type value.<br>
  e.g.:- putchar(65);<br>
  putchar(getch());</p>
<p></p>
<p></p>
<p></p>
<p></p>
<p>ESCAPE SEQUENCES<br>
  These represent non-printable characters and characters that have meaning in 
  the &#8216;C&#8217; program. An escape sequence consists of the escape character 
  (the backslash, \) and a second character.<br>
  &#8216;\a&#8217; Alert (bell)<br>
  &#8216;\b&#8217; Backspace (moves the cursor one space to the left)<br>
  &#8216;\f&#8217; Formfeed (advances the printer paper one page)<br>
  &#8216;\n&#8217; Newline (starts a new line)<br>
  &#8216;\r&#8217; Carriage return (moves the cursor to the beginning of the line)<br>
  &#8216;\t&#8217; Tab<br>
  &#8216;\v&#8217; Vertical tab<br>
  &#8216;\&#8217;&#8217; Single quote<br>
  &#8216;\&#8221;&#8217; Double quote<br>
  &#8216;\?&#8217; Question mark<br>
  &#8216;\\&#8217; Backslash<br>
  &#8216;\0&#8217; NULL<br>
  Escape sequences are used with output functions.<br>
  e.g.:- putchar(&#8216;\a&#8217;); putchar(&#8216;\n&#8217;); etc.<br>
  gets() <br>
  syntax: gets(string_varaiable);<br>
  This function accepts characters from the keyboard until user presses the ENTER 
  key and stores them in the string variable given as the argument.<br>
  e.g.:- char name[20];<br>
  gets(name);<br>
  puts() <br>
  syntax : puts(string_expr);<br>
  Used to display a string of characters at the cursor position on the screen.<br>
  e.g.:- puts(name); puts(gets()); puts(&#8220;\n&#8221;); etc.<br>
  Formatted Input and Output &#8211; printf () and scanf ()<br>
  These functions are called formatted functions as they can read and print data 
  in various pre-specified formats of any data type, which are under the user&#8217;s 
  control. Format specifiers specify the form by which the values of the variables 
  are to be input and printed.<br>
  printf() Used to display data on the Screen<br>
  syntax: printf(&#8220;control string&#8221;, argument_list);<br>
  The argument list consists of constants, variables, expressions or functions 
  sepa-rated by commas. There must be one format command in the control string 
  for each argument in the list and they must match in number, type and order.<br>
  The control string must be enclosed within double quotes. It consists of any 
  printable characters (text), non-printing characters represented by escape sequences 
  and the format commands.<br>
  Format commands defines how the data items are to be printed or accepted. A 
  format command begins with a &#8216;%&#8217; sign and is followed by a format 
  code/specifier appropriate for the data item. Format codes are also called conversion 
  characters. e.g.:- %d for integer, %s for string etc. You can give more than 
  one-format com-mands in the control string.<br>
  Format Codes<br>
  Character %c<br>
  String %s<br>
  Signed Integer %d<br>
  Unsigned Integer %u<br>
  Floating Point (decimal notation) %f<br>
  Floating Point (Scientific notation) %e<br>
  Unsigned Hexadecimal Integer %x<br>
  Unsigned Octal Integer %o<br>
  Signed Long Integer %ld<br>
  Unsigned Long Integer %lu<br>
  Double %lf<br>
  Long double %Lf<br>
  e.g.:- printf(&#8220;Name = %s and Age = %d \n&#8221;, name, age ) ;<br>
  Modifiers for Format Codes<br>
  The format commands/codes can have modifiers, to suitably modify the basic con-version 
  specifications. A format can have more than one modifier.<br>
  FieldWidth Modifier <br>
  This modifier can be used with int, float, double and string. The field width 
  modifier is an integer value, which defines the minimum field width for the 
  data item. Data items of smaller width will be output right justified by default. 
  Larger data items will be printed as it is.<br>
  e.g.:- printf(&#8220;[%10d]&#8221;,456) will be printed as [ 456].<br>
  &#8216;&#8212;&#8217;(left align) modifier<br>
  By default the data item will be printed as right justified within its field 
  width. By using the &#8216;&#8212;&#8217; modifier, the data item will be left 
  justified within its field width.<br>
  e.g.:- printf(&#8220;[%&#8212;d]&#8221;,456) will be printed as [456].<br>
  e.g.:- printf(&#8220;[%&#8212;10d]&#8221;,456) will be printed as [456 ].<br>
  Precision Modifier <br>
  This modifier can be used with float, double or string type data. The modifier 
  is used as &#8216;.n&#8217;, where &#8216;n&#8217; is an integer. If precision 
  modifier is used with data type float or double the digit string indicates the 
  maximum number of digits to be printed to the right of the decimal. When used 
  with a string it indicates the maximum number of characters to be printed.<br>
  If the fractional part of a float or double type data item exceeds the precision 
  modi-fier, then the number will be rounded. If a string length exceeds the specified 
  field length then the string will be truncated.<br>
  e.g.:- printf(&#8220;[10.3f]&#8221;,456.56); will print [ 456.560]<br>
  printf(&#8220;[10.3]&#8221;, &#8220;KERALA &#8221; ); will print [KERALA]<br>
  0 (zero) Modifier <br>
  By default the leading zeroes are padded with spaces. If you use 0 (zero) modifier 
  the leading spaces will be padded with zeroes instead of blanks (spaces).<br>
  e.g.:- printf(&#8220;[010.3f]&#8221;,456.56); will print [000456.560]<br>
  l modifier <br>
  This modifier can be used to display integers as long int. For example the format 
  code for long int is %ld.<br>
  * Modifier <br>
  If the user does not want to specify the field width and precision in advance, 
  but wants through the program, this modifier can be used. But along with this 
  modifier an argument, which tells the width or precision, should be included 
  for each * modifier.<br>
  e.g.:- printf(&#8220; %*s &#8221;, w, name);<br>
  printf(&#8220; %*.*s &#8221;, w, p, name); where w and p are integer values 
  representing field-width and precision.<br>
  scanf() Used to accept data through Keyboard<br>
  syntax: scanf(&#8220; control string &#8221;, argument-list);<br>
  While printf() uses variable names, constants, expressions(calculations), functions 
  as the arguments scanf() uses the addresses of variables in the memory. Precede 
  the variable name with an &amp;(address of ) operator with all types except 
  string (ar-rays) because it is a derived data type. All the format codes are 
  exactly same for the scanf() also.<br>
  e.g.:- scanf( &#8220; %d %s&#8221;, &amp;age, name);<br>
  scanf( &#8220;%10s&#8221;, name);<br>
  scanf() uses non-printing characters like blank(space), tab, newline (Enter 
  Key) to decide when an input field ends and another input field begins.<br>
  Multi-Dimensional Arrays<br>
  A multi-dimensional array requires a separate pair of square brackets for each 
  dimension. i.e., a two dimensional array will require two pairs of square brackets, 
  and a three-dimensional array will require three pairs of square brackets and 
  so on.<br>
  A two-dimensional array can be treated as an array of single dimensional arrays.<br>
  syntax : data-type array-name [rows][columns] ;<br>
  e.g.:- int arr[3][4]; char names[10][25]; etc.<br>
  Each dimension of the array is subscripted (indexed) from 0(zero) to its maximum 
  size minus one. The first subscript selects the row and the second subscript 
  selects the column within that row.<br>
  Multi-dimensional arrays can be initialised as follows,<br>
  int arr[3][4]={1,2,3,4,5,6,7,8,9,10,11,12};<br>
  The initialising rule is that the last subscript increases most rapidly, and 
  the first subscript increases least rapidly. Thus the elements of a double-dimensional 
  array will be assigned by rows. i.e., the elements of the first row will be 
  assigned, then the elements of the second row and so on.<br>
  The initialisation can be done row by row,<br>
  i.e., int arr[3][4]={ {1,2,3,4}, {5,6,7,8}, {9,10,11,12} };<br>
  i.e., surrounding the elements of each row by braces.<br>
  A two-dimensional array can also initialised in the form of a matrix.<br>
  i.e., int arr[3][4]={ {1,2,3,4},<br>
  {5,6,7,8},<br>
  {9,10,11,12}<br>
  };<br>
  Commas are required after each brace that closes off a row, except in the case 
  of last row. We can access the elements of a two-dimensional array using row 
  and column subscripts.<br>
  e.g.:- arr[2][3]++; printf(&#8220;%d&#8221;, arr[1][3]); scanf(&#8220;%d&#8221;, 
  &amp;arr[2][2]); etc.<br>
  A string (character) array can be initialised as follows,<br>
  char names[3][10]={{&#8216;H&#8217;,&#8217;e&#8217;,&#8217;l&#8217;,&#8217;l&#8217;,&#8217;o&#8217;,&#8217;\0&#8217;},{&#8216;E&#8217;,&#8217;v&#8217;,&#8217;e&#8217;,&#8217;r&#8217;,&#8217;y&#8217;,&#8217;\0&#8217;},{&#8216;B&#8217;, 
  &#8217;o&#8217;, &#8217;d&#8217;, &#8217;y&#8217;, &#8217;\0&#8217;} };<br>
  OR<br>
  char names[3][10]={&#8220;Hello&#8221;, &#8221;Every&#8221;, &#8221;Body&#8221;};<br>
  OR<br>
  char names[3][10]={ &#8220;Hello&#8221;,<br>
  &#8220;Every&#8221;,<br>
  &#8220;Body&#8221;<br>
  };<br>
  You can access each character (element) in the array using subscripts.<br>
  e.g. :- printf(&#8220;%c&#8221;, names[1][2]); will return e.<br>
  To access the contents as strings use the row subscript only<br>
  e.g.: - printf(&#8220;%s&#8221;, names[1]); will print Every and <br>
  scanf(&#8220;%s&#8221;, names[2]); will read data to the third row.<br>
  Operators<br>
  Operators are used in programs to manipulate data and variables. An operator 
  is a symbol that tells the computer to perform certain mathematical or logical 
  operation. Operators operate on constants or variables, which are called operands. 
  In &#8216;C&#8217; operators are classified Unary, Binary and Ternary operators 
  act on three data elements.<br>
  Arithmetic Operators <br>
  They are classified into two classes, binary arithmetic operators and unary 
  arithmetic operators.<br>
  Binary Arithmetic Operators <br>
  They are,<br>
  + Addition<br>
  &#8212; Subtraction<br>
  / Division<br>
  * Multiplication<br>
  % Modulus (remainder)<br>
  The modulus operator, % is used to obtain the remainder after integer division.<br>
  e.g.:- printf(&#8220; %d &#8220;, 13%5); will print 3.<br>
  Both the operands of modulus operator must be integer.<br>
  Unary Arithmetic Operators <br>
  They are unary minus (&#8212;), unary plus (+), the increment operator (++) 
  and the decrement (&#8211; &#8211;). The unary plus and minus operators used 
  to show the signs of the numeric data elements. e.g.:- a= &#8211;12; b= &#8211;a;<br>
  The increment operator (++) adds 1 to the operand while the decrement operator 
  (&#8211; &#8211;) subtracts 1. These can be placed on both sides of the operands. 
  i.e., ++m; m++;<br>
  When they form statements independently they mean the same. ie., ++m; and m++; 
  both are equivalent to m=m+1.But the behave differently when they are used in 
  expressions on the right-hand side of an assignment statement. i.e., prefixing 
  &amp; post-fixing.<br>
  eg:- m =5; ???? prefixing <br>
  y =++m; The value of y and m would be 6. <br>
  but in the case of,<br>
  m = 5; ???? postfixing <br>
  y = m++; The value of m would be 6 and y would be 5.<br>
  This difference is because a prefix operator first adds 1 to the operand and 
  then the result is assigned to the variable on left. But a post-fix operator 
  first assigns the value to the variable on left and then increments the operand. 
  ie.,<br>
  m =5; prefixing m=5;<br>
  y =++m; is equivalent to m=m+1;<br>
  y=m; <br>
  m = 5; postfixing m=5;<br>
  y = m++; is equivalent to y=m;<br>
  m=m+1;<br>
  sizeof() Operator <br>
  sizeof is an unary operator, which returns size of the expression given as the 
  argu-ment.<br>
  e.g.:- a = sizeof(int); will store 2 to the variable a.<br>
  printf(&#8220; %d &#8221;, sizeof(long int) ); will print 4.<br>
  char name[10]; int marks[10];<br>
  printf(&#8220; %d -- %d &#8221;, sizeof(name), sizeof(marks) ); will print 10 
  &#8211; 20.<br>
  Assignment Operators <br>
  The assignment operators are used to assign the result of an expression to a 
  vari-able. The default assignment operator is &#8220;=&#8221;. Turbo C also 
  allows a set of shorthand assignment operators.<br>
  syntax : variable operator= numeric_expression<br>
  Operator can be any of the binary arithmetic operators. The operator, operator= 
  is known as the shorthand assignment operator.<br>
  e.g.:- a += 2; is equivalent to a = a + 2;<br>
  a &#8211;= 2; is equivalent to a = a &#8211; 2;<br>
  a *= 2; is equivalent to a = a * 2;<br>
  a /= 2; is equivalent to a = a / 2;<br>
  a %= 2; is equivalent to a = a % 2;<br>
  Relational Operators <br>
  They are &lt;, &lt;=, &gt;, &gt;=, == (is equal to), != (is not equal to).<br>
  A relational expression consists of a combination of relational operators and 
  oper-ands, where an operand can be a constant, a variable or an arithmetic expression.<br>
  Every relational expression has a value, which is true or false. If the relation 
  is true, the expression has a value of 1(one) and if the relation is false, 
  it has a value of 0(zero).<br>
  Logical Operators <br>
  They are , &amp;&amp; (logical AND),<br>
  || (logical OR) and<br>
  ! (logical NOT).<br>
  Where &amp;&amp; and || are binary operators and, ! is an unary operator. These 
  operators can be used to create compound conditions. The &amp;&amp; and || have 
  two operands and are usually relational expressions, which have either a true 
  or a false value.<br>
  (expr1 &amp;&amp; expr2) is true only if both expr1 and expr2 are true, otherwise 
  it is false. (expr1 || expr2) is true if either or both expr1 and expr2 are 
  false, is false only if both expr1 and expr2 are false. ( !expr1) is true if 
  expr1 is false, is false if expr1 is true. <br>
  Statements in &#8216;C&#8217;<br>
  A statement is a complete instruction to the computer. It indicates a specific 
  action. Statements can be classified into two, i) Simple Statements ii) Compound 
  State-ments.<br>
  Simple Statements <br>
  A semicolon at the end indicates simple statements. Simple statements can be 
  either declaration statements like int count, num;, assignment statements like 
  count=10; and function statements like printf( &#8220;Hello&#8221; );, getch(); 
  etc.<br>
  Compound Statements <br>
  A compound statement is two or more statement grouped together by enclosing 
  them in braces. It is also called a code block. The grouping ensures that either 
  all the statements in the block are executed or none of them are executed. A 
  compound statement is syntactically equivalent to a single statement. But there 
  is never a semicolon after the right brace that ends a block.<br>
  If Statement<br>
  syntax : if(expression)<br>
  statement1;<br>
  next statement;<br>
  The expression is a relational expression and it should always be enclosed in 
  paren-theses. If the expression is true (non-zero), then statement1 is executed. 
  And after that the next statement is executed. If the expression is false (zero), 
  statement1 is not executed and the control passes directly to the next statement.<br>
  The statement part of the if (statement1) may be a simple statement or it may 
  be a compound statement. i.e., if more than one statements are to be executed, 
  when the expression becomes true, then you should enclose that set of statements 
  within braces to create a code block or a compound statement.<br>
  syntax : if(expression)<br>
  {<br>
  staement1;<br>
  statement2;<br>
  &#8230;&#8230;&#8230;&#8230;<br>
  statement-n;<br>
  }<br>
  next statement;<br>
  When expression is true, the block of statements are executed sequentially after 
  that, next statement is executed. When condition is false the compound statement 
  block is skipped and next statement is executed.<br>
  IF...ELSE <br>
  syntax: if( expression )<br>
  statements1;<br>
  else<br>
  statements2;<br>
  The statements, statements1 and statements2 both can be a simple statement or 
  a compound statement enclosed in braces. If the expression evaluates to true 
  (non-zero), statements1 is executed. If it is false (zero) then statements2 
  is executed.<br>
  eg:-<br>
  # include &lt;stdio.h&gt;<br>
  main()<br>
  {<br>
  int x;<br>
  printf(&#8220;Enter a number : &#8221;);<br>
  scanf(&#8220;%d&#8221;, &amp;x);<br>
  if(x&gt;10)<br>
  printf(&#8220;x is greater than 10&#8221;);<br>
  else<br>
  {<br>
  printf(&#8220;The condition is false&#8221;);<br>
  printf(&#8220; x is less than or equal to 10&#8221;);<br>
  }<br>
  getch();<br>
  }<br>
  The While Loop<br>
  syntax : while( condition )<br>
  statement1;<br>
  next statement;<br>
  The condition to be tested must be enclosed in parentheses. The loop continues 
  until the condition becomes false. Then the control goes to the statement immediately 
  follow the code block. ie., next statement;<br>
  e.g.(1) <br>
  # include &lt;stdio.h&gt;<br>
  main()<br>
  {<br>
  int i=0;<br>
  while(i&lt;=10)<br>
  {<br>
  printf(&#8220;%d \n&#8221;, i);<br>
  i++;<br>
  }<br>
  printf(&#8220;loop completed&#8221;);<br>
  getch();<br>
  }</p>
<p>e.g.:- (2)</p>
<p># include &lt;stdio.h&gt;<br>
  main()<br>
  {<br>
  char name[20];<br>
  int x=0;<br>
  printf(&#8220;Enter your name : &#8220;);<br>
  scanf(&#8220;%s&#8221;, name);<br>
  while(name[x]!=NULL)<br>
  {<br>
  printf(&#8220;%c\n&#8221;,name[i]);<br>
  i++;<br>
  }<br>
  printf(&#8220;That is the loop&#8221;);<br>
  getch();<br>
  }<br>
  The for loop<br>
  syntax : for( initialise counter; conditional test; re-evaluation parameter)<br>
  statements ;<br>
  The for statement specifies three expressions in a single line, to control the 
  looping process. These expressions should be separated by semicolons and should 
  be enclosed in parentheses.<br>
  The three expressions are,<br>
  (i) The initial value of the counter <br>
  (ii) The conditional test for exiting the loop<br>
  (iii) The expressions used to give the counter a new value.<br>
  The statement, which forms the body of the loop, can be either a simple statement 
  or a compound statement. The initialise counter is executed only once, before 
  any of the loop statements are executed. Then the conditional test is performed. 
  If this expression is true (non-zero), the statements of the loop are executed 
  once. Then counter is assigned new value using the re-evaluation parameter. 
  The conditional test is repeated again, using the new value of the counter. 
  The loop is repeated until the conditional test becomes false (zero).<br>
  The while loops and for loops is entry-condition loops. i.e., The condition 
  will be checked before the statements of loop are executed (pre-checking). Therefore 
  there is a possibility that the loop is never traversed.<br>
  Any of the three parts of the for loop can be omitted. Although the semicolons 
  must remains. If all the three are omitted then the loop becomes an infinite 
  loop.<br>
  e.g.:- for( ; ; )<br>
  statements;<br>
  The body of the loop can be empty. ie., all of the work is done in the test 
  and incre-ment parts. But the grammatical rules of &#8216;C&#8217; require that 
  loop statements have a body. Then you can use only a semicolon, called the NULL 
  statement as the body of the loop.<br>
  e.g.:- for(x=1; x&lt;=10; x++)<br>
  ;<br>
  This loop will work until the value of x becomes greater than 10 and no other 
  result will be produced. This can be also represented as <br>
  for(x=1;x&lt;=10; x++);<br>
  Therefore placing a semicolons at the end of a for loop will not create an error 
  in &#8216;C&#8217;.<br>
  You can include more than one initialisation or re-evaluation expressions in 
  the for loop using the comma operator.<br>
  eg:- for(x=1, j=1; str[x]!=NULL; x++, j++)<br>
  statements;<br>
  BREAK Statement<br>
  The break statement in &#8216;C&#8217; provides an early exit (ie., exit from 
  the loop without testing the loop condition) from the for, while and the do&#8230;while 
  loops, and also from the switch statement.<br>
  syntax : break;<br>
  When the break statement is encountered in a &#8216;C&#8217; program, control 
  passes immedi-ately to the first statement after the loop. Usually break statement 
  is associated with an if statement which enables a condition to be tested.<br>
  CONTINUE Statement<br>
  syntax : continue;<br>
  The continue statement causes the next iteration of the enclosing loop to begin. 
  When this statement is encountered, the remaining statements in the body of 
  the loop are skipped and the loop starts again after checking the condition. 
  Usually continue statement is used with an if statement.</p>
<p></p>
<p>The DO&#8230;WHILE Loop<br>
  syntax : <br>
  do<br>
  statement1;<br>
  while(condition);<br>
  next statement;<br>
  The statement can be either simple statement or compound statement. This loop 
  is also called do loop/statement. do..while loop is an exit condition loop(post-test).i.e., 
  the test condition is evaluated only after the loop has been executed. Thus 
  the loop will be executed at least once.<br>
  The statement is first executed, then the condition is checked. If it is true 
  (non-zero), the control is transferred to the do statement and the process is 
  repeated. When the condition becomes false (zero), then control is transferred 
  to the next statement following the loop statement.<br>
  The Switch Statement<br>
  The switch statement is a special multi-way decision-maker that tests whether 
  an expression matches, one of a number of constant values, and branches accordingly.<br>
  syntax : <br>
  switch(expression/variable)<br>
  {<br>
  case value1 :<br>
  statement1;<br>
  break;<br>
  case value2 :<br>
  statements2;<br>
  break;<br>
  &#8230;&#8230;&#8230;&#8230;&#8230;.<br>
  [default : <br>
  statements-n;]<br>
  }<br>
  next statement;<br>
  Where switch, case and default are the keywords and statements1, statements2, 
  statements-n can be simple statements or a compound statement, which need not 
  be enclosed in braces.<br>
  The expression following the switch must be enclosed in a pair of parentheses 
  and the body of switch should be enclosed within braces. The body consists of 
  many case labels (i.e., value1, value2, etc.) each one of which has an action 
  associated with it. The type of the expression given and type of case labels 
  should be compati-ble. Each case must be labelled by an integer or character 
  constant or constant expression, which does not consist of any variable names. 
  Case labels must be unique.<br>
  In the switch statement, the expression is evaluated, and the value is compared 
  with the case labels in the given order. If a label matches with the value of 
  expression, the statement(s) mentioned against it will be executed. The break 
  statement at the end of each block signals the end of the particular case and 
  causes an exit from the switch statement, transferring the control to the next 
  statement following the closing brace of the switch statement.<br>
  If you don&#8217;t use the break statement after each action. The execution 
  falls through to the next. i.e., every statement from the matched label to the 
  end of the switch will be processed.<br>
  The statements against default will be executed, if none of the other cases 
  is satis-fied. The default part is optional.<br>
  The Conditional Operator (?:)<br>
  This operator provides conditional execution of statements and it has two parts, 
  &#8216;?&#8217; and &#8216;:&#8217;. This operator is a ternary operator and 
  operates upon three operands.<br>
  syntax: condition?expression1:expression2<br>
  The condition is evaluated and if the result is true (non-zero) expression1 
  is evalu-ated, else if the condition becomes false (zero) then the expression2 
  is evaluated. Only of the expressions will be executed. You can mix this operator 
  to create com-plex equations.<br>
  E.g.: - To find out the largest among the three numbers.<br>
  # include &lt;stdio.h&gt;<br>
  void main()<br>
  {<br>
  int a=10,b=20,c=16,large;<br>
  large = (a&gt;b)?(a&gt;c)?a: c: (b&gt;c)? b: c;<br>
  printf(&#8220;largest number : %d&#8221;, large);<br>
  }<br>
  Functions<br>
  A function is a self-contained program segment that carries out a specific, 
  well- defined task. C functions can be classified into two categories, Library 
  functions and User-defined functions. Printf and scanf are examples of library 
  functions and main() is an example of user-defined functions.<br>
  A program can be modularised through the use of user-defined functions. Large 
  and complicated programs can be divided into functional parts, then make it 
  easy for testing, debugging and maintaining. Functions should be written independent 
  of system dependent feature, making more portable. The same function can be 
  called from many points, there by avoiding repetition of code.<br>
  A function definition is subdivided into three main components<br>
  &#8226; Function header<br>
  &#8226; Argument declarations<br>
  &#8226; Body of the function</p>
<p> General form of function definition is as follows<br>
  data-type name(arguments)<br>
  argument declarations;<br>
  {<br>
  statements;<br>
  return(&lt;expr&gt;);<br>
  }<br>
  The function header consists of function storage class, function Datatype, function 
  name and set of arguments separated by commas, enclosed in parentheses. A pair 
  of empty parentheses must follow the function name if the function definition 
  does not include any arguments. Arguments are declared outside the body of the 
  func-tions, before the first compound statement.<br>
  e.g.:-<br>
  int max(m, n)<br>
  int m, n;<br>
  {<br>
  statements;<br>
  return;<br>
  }<br>
  But ANSI standard allows the user to combine the function header and argument 
  declarations all in one line.<br>
  e.g.:- <br>
  int max(int m, int n)<br>
  {<br>
  statements;<br>
  return;<br>
  }<br>
  These arguments allow data to be transferred from the calling statement to the 
  function. Function body consists of a compound statement, which must be enclosed 
  within braces. A function can be called by using the function name followed 
  by a list of actual arguments enclosed in parentheses in a statement.<br>
  e.g.:- x = max(num1, num2);<br>
  Arguments appearing in the function header are also called as formal arguments 
  or formal parameters. Arguments appearing in the function reference in the calling 
  statement are called the actual arguments, since the actual data is transferred 
  to the function through them. Any formal argument, which is not declared, is 
  taken to be of type int by default.<br>
  Actual arguments can be expressed as constants, variables, expressions or func-tions 
  and the formal arguments must be variables. The actual arguments must be identical 
  in number, order and type with the formal arguments.<br>
  When a function call is made, only a copy of the values of actual argument is 
  passed in the called functions. What occurs inside the function will have no 
  effect on the variables used in the actual argument list.<br>
  Identifiers used as formal arguments are considered local to the function and 
  they are released from the memory when the function terminates. Therefore other 
  vari-ables of arguments appearing outside the function can have the same name 
  as those of the formal arguments.<br>
  The Return statement causes the function to terminate and the control to be 
  return to the point from where the function was called. A function can send 
  back a value to the calling program using the Return statement. A called function 
  can also return one value per call. Return can be used differently like, <br>
  return;<br>
  return &lt;expr&gt;;<br>
  return(&lt;expr&gt;);<br>
  The plain return; does not return any value, only terminates the function. Bur 
  the second and third model returns a value to the calling program before terminating 
  the function. <br>
  E.g.:-(1) e.g.:-(2)<br>
  int max(int m, int n) int xyz()<br>
  { {<br>
  statements; statements;<br>
  return y; return;<br>
  } }<br>
  By default all 'C' function returns the type int , when no other type is specified. 
  To enable a calling function to receive a non-integer value from a called function,<br>
  &#8226; The data type, corresponding to the data required must be mentioned 
  in the function header. The data type tells the compiler, the type of data the 
  function is to return.<br>
  e.g.:-<br>
  float div(float num1, float num2)<br>
  {<br>
  return(num1/num2);<br>
  }<br>
  &#8226; The called function must be declared at the start of the body in the 
  calling func-tion like any other variable. This is to tell the calling-function 
  the type of the data that the function is actually returning. This is called 
  Prototyping.<br>
  e.g.:- <br>
  float div(float num1, float num2);<br>
  A function that does not return any value can not be used in an expression. 
  It can only used as an independent statement. If the function does not returns 
  any value then it can be declared as a void type function. void means nothing. 
  That is void tells the compiler that the function do not return any values. 
  <br>
  e.g.:- <br>
  void sample(void);<br>
  FUNCTION WITH ARRAYS<br>
  'C' also allows passing the values of an array to a function. To pass an array 
  to a called function mention only the name of the array with out any subscripts 
  and size of the array, as arguments.<br>
  e.g.:-<br>
  main()<br>
  {<br>
  float ar[25]; <br>
  check (ar);<br>
  }<br>
  In the function header , the formal argument should be an array name with empty 
  brackets.<br>
  e.g.:-<br>
  float check( xy[ ] )<br>
  {<br>
  statements;<br>
  }<br>
  If a function changes the values of an array elements then these changes will 
  be made to the original array that passed to the function. When the entire array 
  is passed as an argument the contents of the array are not copied into the formal 
  parameters array, instead, information about the addresses of array elements 
  are passed into the function. Therefore any changes introduced to the array 
  elements in the function are reflected in the original array in the calling 
  function.<br>
  RECURSION<br>
  Recursion is a process where a function may invoke itself from within its body(direct 
  method) or a function may be invoked by another which was itself invoked by 
  the first function (indirect method).</p>
<p><br>
  main( ) main() <br>
  { {<br>
  ------- indirect ----------<br>
  fun( ); main();<br>
  ------ direct ----------<br>
  } }<br>
  fun( ) <br>
  { <br>
  ----- <br>
  main( ); <br>
  ----- <br>
  }</p>
<p> <br>
  e.g.:- main()<br>
  {<br>
  printf(&quot;This is an example of recursion \n&quot;);<br>
  main();<br>
  }<br>
  When executed, the above example will produce the output indefinitely. To stop 
  execution press Ctrl+Break.<br>
  Each recursive function must specify an exit condition for it to terminate, 
  otherwise it will go indefinitely. Recursive function can be effectively used 
  to solve problems where the solution is expressed in terms of successively applying 
  the same solution to subsets of the problem.<br>
  Q1. Write a program to generate a sequence of Fibonacci numbers.(Fibonacci numbers 
  form a sequence, where end number is the sum of the previous two num-bers, with 
  the first two numbers being 1.) [ e.g.:- 1,1,2,3,5,8,13,21,&#8230;&#8230;&#8230;. 
  ]<br>
  # include &lt;stdio.h&gt;<br>
  long int fibo(int m);<br>
  main()<br>
  {<br>
  int n, x;<br>
  long i;<br>
  printf(&quot;%Enter no. of Fibonacci numbers : &quot;);<br>
  scanf(&quot;%d&quot;, &amp;n);<br>
  for(x=1; x&lt;=n; x++)<br>
  {<br>
  printf(&quot;%ld&quot;, fibo(x) );<br>
  }<br>
  }<br>
  long int fibo(int m)<br>
  {<br>
  if(m&lt;=2)<br>
  return 1;<br>
  else<br>
  return(fibo(m-1)+fibo(m-2));<br>
  }<br>
  If the user enters 4 to the variable n, then,<br>
  fibo(1) returns 1<br>
  fibo(2) returns 1<br>
  fibo(3) calls fibo(2) and fibo(1)<br>
  Then the result is calculated backward as, fibo(3) = 1 + 1 = 2<br>
  fibo(4) calls fibo(3) and fibo(2)<br>
  fibo(3) calls fibo(2) and fibo(1)<br>
  fibo(2) returns 1<br>
  fibo(1) returns 1<br>
  so the result is calculated backward as, fibo(3) = 1 + 1 = 2<br>
  fibo(4) = 2 + 1 = 3<br>
  Q2.Write a function factorial to find out the factorial of the given number.<br>
  factorial(int n)<br>
  {<br>
  int fact;<br>
  if(n==1)<br>
  return 1;<br>
  else<br>
  fact = n * factorial(n-1);<br>
  return fact;<br>
  }<br>
  Assume n=3. Since the value of n is not 1, the statement, fact =n * factorial(n-1); 
  will be executed with n=3, i.e., fact=3 * factorial(2); factorial(2) will return 
  2*factorial(1). This time factorial() is called with n=1, and the function returns 
  1. Therefore the result is.<br>
  fact = 3*factorial(2)<br>
  = 3*2*facorial(1)<br>
  = 3*2*1<br>
  = 6<br>
  Q3. To print numbers up to the user given number from 1.<br>
  # include &lt;stdio.h&gt; <br>
  display(int i); <br>
  main() display(int i)<br>
  { {<br>
  int i; if(i = = 0)<br>
  clrscr(); return;<br>
  printf(&quot;Enter Number : &quot;) ; else<br>
  scanf(&quot;%d&quot;, &amp;i); display(i - 1);<br>
  display(i); printf(&quot;%d \n&quot;, i);<br>
  return; }<br>
  } </p>
<p><br>
  STORAGE CLASSES<br>
  A variable name identifies some physical location within computer, where the 
  string of bits representing the variable&#8217;s value is stored. There are 
  basically two kinds of locations in a computer where a value can be kept, memory 
  (RAM) or one of the CPU registers. It is a variable storage class, which determines 
  whether it is to be stored in memory or in a register. The storage class also 
  determines the scope and longevity (lifetime or permanence) of each class of 
  variables. The scope of vari-ables determines over what parts of the program 
  a variable is available for use (active). Longevity refers to the period during 
  which a variable retains a given value during execution of a program (alive). 
  Thus storage class determines the location of variable in the computer, the 
  scope and longevity of the variables in the program. There are four storage 
  classes in &#8216;C&#8217; there are automatic, external, static, register.<br>
  AUTOMATIC VARIABLES<br>
  Automatic variables are declared within a function and can be accessed only 
  from within the function where they are declared i.e., from the point of its 
  definition to the end of the function. i.e., it is local or private to the function 
  because automatic variables are created when function is called and destroyed 
  automatically when the function is exited. These classes of variables are also 
  called internal variables.<br>
  When a variable is declared inside a function it is automatically assigned a 
  class auto and the compiler sets aside the computers memory area for the variable. 
  Automatic variables defined in different functions are independent of one another, 
  though they may have the same name.<br>
  Formal arguments of a function are automatic, unless a different storage is 
  enclosed within the function declaration. It is not necessary to use the keyword 
  auto at the beginning of each variables determines the automatic storage class.<br>
  An automatic variable does not retain its value once the function terminates. 
  There-fore it is necessary to reassign values every time a function is entered. 
  The scope of the automatic variables can be smaller than the entire function, 
  if it is declared in from within single compound statement. The scope then will 
  be restricted to that compound statement.<br>
  e.g.: -<br>
  main( ) func1( )<br>
  { {<br>
  int x=10; int y=20;<br>
  printf(&#8220;%d&#8221;,x); printf(&#8220;%d&#8221;,y);<br>
  func1(); prinrf(&#8220;%d&#8221;,x);<br>
  printf(&#8220;%d&#8221;,y); return;<br>
  } }<br>
  In the above example errors will occurs at two lines. First the printf(%d&#8221;, 
  y); state-ment in the main() error will be undefined variable the second the 
  printf(&#8220;%d&#8221;, x); statement in the func1() error will be the same, 
  undefined symbol. This is because the automatic variables declared in one function 
  is local to that function.</p>
<p>e.g.: -<br>
  main()<br>
  {<br>
  int x=5;<br>
  printf(&#8220;%d&#8221;, x);<br>
  {<br>
  int y=2;<br>
  printf(&#8220;%d&#8221;, x);<br>
  printf(&#8220;%d&#8221;, y);<br>
  } <br>
  printf(&#8220;%d&#8221;, y);<br>
  }<br>
  Here also an undefined variable error will occur at the last printf(&#8220;%d&#8221;, 
  y) statement. Here all the variables declared in the same function but the variable 
  y is declared in the inner most compound statement, therefore the scope of y 
  is only within that compound statement.<br>
  e.g.: -<br>
  main()<br>
  {<br>
  int m=100;<br>
  function2 ();<br>
  printf(&#8220;%d&#8221;, m);<br>
  }<br>
  function1()<br>
  {<br>
  int m=10;<br>
  printf(&#8220;%d&#8221;, m);<br>
  }<br>
  function2()<br>
  {<br>
  int m=100;<br>
  function1();<br>
  printf(&#8220;%d&#8221;, m);<br>
  }<br>
  Output will be <br>
  10<br>
  100<br>
  1000<br>
  Because m in the function does not affect its value in other functions, and 
  the value of m is defined when it leaves the function.<br>
  EXTERNAL VARIABLES<br>
  Variables that are both alive and active throughout the entire program are known 
  as external variables, also called global variables. External variable definition 
  must be defined outside the functions. That access the external variables and 
  usually before the function definition. The keyword extern is not required as 
  the class is determined by the position of the definition. External variables 
  are automatically initialized by the compiler to 0. They can be initialized 
  with other values. The initialization must be done with constants and not with 
  expressions. The external variable definition reserves storage space in memory. 
  The scope of an external variable is from the point of their definition to the 
  remainder of the program. They are normally written at the beginning of a program 
  so that their scope extends to all the functions in a program values can be 
  assigned to external variables by any functions within their scope and the values 
  are also available to all functions within the scope. The values are lost only 
  when the program terminates.<br>
  External variables provides an easy way of transferring data between functions 
  as data is shared by all functions but there is a possibility of making unwanted 
  changes by the functions. And the external variables are not released from the 
  memory until the program ends. This makes debugging difficult, as one must keep 
  track of all global variables in all functions.<br>
  When a local variable (automatic class) and a global variable (extern class) 
  have the same name, the local variable will have precedence over the global 
  one in the function it is declared.<br>
  e.g.:-<br>
  # include &lt;stdio.h&gt; <br>
  int num; will return,<br>
  main() 100<br>
  { 10<br>
  num=100; 100<br>
  printf(&quot;%d \n&quot;, num); <br>
  function(); When the function references the variable num, it will be <br>
  printf(&quot;%d&quot;, num); referencing only its local variable, not the global 
  one. The <br>
  } value of num in main will not be affected.<br>
  function() <br>
  { <br>
  int num=10; <br>
  printf(&quot;%d \n&quot;, num); <br>
  num+=1000; <br>
  }<br>
  EXTERANAL VARIABLE DECLARATION<br>
  An external variable definition must be defined outside the functions, that 
  access the external variables and usually before the function definitions. An 
  external variable definition automatically allots space for the external variables 
  in memory. The system initialises the external variables to zero. All the functions 
  can access the external variables from the point of its definition.<br>
  e.g.:-<br>
  int num;<br>
  main()<br>
  {<br>
  fun1();<br>
  printf(&quot;%d \n&quot;, num);<br>
  func2();<br>
  }<br>
  func1()<br>
  {<br>
  printf(&quot;%d \n&quot;, num);<br>
  num+=20;<br>
  }<br>
  fun2();<br>
  {<br>
  printf(&quot;%d \n&quot;, num);<br>
  }<br>
  But, if the external variable is defined after the accessing functions, the 
  functions cannot access those variables.<br>
  main()<br>
  {<br>
  printf(&quot;%d \n&quot;, num);<br>
  fun1();<br>
  }<br>
  fun1()<br>
  {<br>
  printf(&quot;%d \n&quot;, num);<br>
  }<br>
  int num; /* external variable definition */<br>
  Declaring the variables within the functions as external can solve this prob-lem. 
  External variable declarations are needed if the function definition in which 
  the variable is used comes before the external variable definition. An external 
  variable declaration must begin with the storage class specifier extern. An 
  external variable declaration will not allocate the storage space in memory, 
  also initial values cannot be assigned to external variable declarations.<br>
  e.g.:-<br>
  main()<br>
  {<br>
  extern int num; /* external variable declaration */<br>
  printf(&quot;%d \n&quot;, num);<br>
  fun1();<br>
  }<br>
  fun1()<br>
  {<br>
  extern int num; /* external variable declaration */<br>
  printf(&quot;%d \n&quot;, num);<br>
  }<br>
  int num; /* external variable definition */</p>
<p>STATIC VARIABLES<br>
  Static variables are defined within a function and therefore their scope is 
  local to the function in which they are defined from the point of their definition 
  and not outside it. i.e. not outside the function. Unlike automatic variables, 
  static variables retain their values even after the function terminates, till 
  the end of the program. As a result, if a function terminates and then is re-entered 
  later, the static variables defined within that function would still retain 
  their former values. The variable declaration must begin with the static storage 
  class designation.<br>
  e.g.:- static int num;<br>
  Initial values can be assigned to variables within static variable declarations 
  and the initial values must be expressed as constants and not expressions. The 
  compiler automatically assigns the default value of zero to any static variable, 
  which is not initialised. The values are not re-initialised when a function 
  is re-entered. The vari-ables retain their previous values. Initialisation takes 
  place only once, when the program is compiled.<br>
  It is possible to define static variables having the same names as external 
  variables. The local variables (static as well as automatic) take precedence 
  over the external variables and the values of the external variables will be 
  unaffected by any manipula-tion of the local variables. External variables of 
  the same name as local variables in a function can not be accessed in that function.<br>
  e.g.:- 1<br>
  main() <br>
  { fun()<br>
  int i; { <br>
  for(i=0;i&lt;3;i++) int num=65;<br>
  { printf(&quot;%d - - %c \n&quot;, num, num);<br>
  fun(); num++;<br>
  } }<br>
  } <br>
  Will return, 65 - - A This is because each time fun() is called, the variable 
  num <br>
  65 - - A which has a storage class auto is re-initialised to 65 (ASCII - A).<br>
  65 - - A When the function, terminates the new value of num is lost<br>
  ( ASCII - 66).</p>
<p></p>
<p>e.g.:- 2<br>
  main() <br>
  { fun()<br>
  int i; { <br>
  for(i=0;i&lt;3;i++) static int num=65;<br>
  { printf(&quot;%d - - %c \n&quot;, num, num);<br>
  fun(); num++;<br>
  } }<br>
  } <br>
  Will return, 65 - - A When the storage class is static, num is initialised to 
  65 <br>
  66 - - B only once when the program is compiled. At end of the first <br>
  67 - - C function call, num has a value of 66 (ASCII - B) and in the next call 
  num has a value of 67 (ASCII - C). At the end of last function call num has 
  a value of 68 (ASCII - D). This value is lost when the program terminates.<br>
  REGISTER VARIABLES<br>
  Computers have internal registers in their ALU which are used to store data 
  tempo-rarily that needs to accessed repeatedly. Intermediate results of calculations 
  are also stored in registers. Operations can be performed upon the data stored 
  in registers more quickly than upon the data stored in memory (RAM). The keyword 
  register must be used to define the register variables. <br>
  e.g.:- register int i;<br>
  If the compiler finds a free register, and if the machine's registers are big 
  enough to hold the variable, the compiler may place that variable's value in 
  that register. Oth-erwise, the compiler treats register variables as any automatic 
  variables.<br>
  i.e., it stores them in the memory (RAM).<br>
  The scope and initialisation of the register variables is the same as for the 
  automatic variables, except for the location of storage. i.e., the register 
  variables are local to a function and they are created only when the function 
  is invoked and the value will be lost once the function is exited from. The 
  system does not initialise these variables.<br>
  The number of registers available is limited. Therefore you should determine 
  which variables in the program are used most often, then declare them as register 
  variables.<br>
  e.g.:-<br>
  main()<br>
  {<br>
  register int i;<br>
  for(i=0; i&lt;100; i++)<br>
  {<br>
  printf(&quot;%d&quot;, i);<br>
  } <br>
  }</p>
<p> <br>
  POINTERS in C<br>
  A pointer is a variable, which contains the address of a memory location or 
  variable, rather than its stored value. A pointer provides an indirect way of 
  accessing the value of a data item (variable). For each type of data, it is 
  possible to declare a corre-sponding type of pointer. The type associated with 
  pointers is pointer, but pointers point to variables of other data types.<br>
  The reference (&amp;) and Indirection (*) operators<br>
  Pointers can be manipulated in C by using two unary operators. The reference 
  or address of operator, denoted by &amp; and the indirection operator denoted 
  by *. The computers memory is divided into uniquely addressable units called 
  words or bytes. The addresses start from 0 and these are unsigned numbers. <br>
  Consider an integer variable, i with value 500.<br>
  i.e., int i = 500;<br>
  This declaration tells the compiler to,<br>
  i) Reserve space in memory to hold the integer value,<br>
  ii) Associate the name i with this memory location,<br>
  iii) Store the value 500 at this location<br>
  Suppose the address of the memory location is 65496,<br>
  i ? Location name<br>
  500 ? Value at location<br>
  65496 ? Location no.(address)<br>
  The address of a variable can be obtained by prefixing the variable with the 
  refer-ence operator. (e.g.:- &amp;i) i.e., The address operator is used to return 
  the address of the variable.<br>
  e.g.:- <br>
  main()<br>
  {<br>
  int i=500;<br>
  printf (&#8220;address of i = %u&#8221;, &amp;i);<br>
  printf (&#8220;Value of i = %d&#8221;, i);<br>
  }<br>
  Indirection operator, * is also called value at address operator. Its operand 
  is the address of a memory location and it returns the value stored at that 
  address. It works only on pointer variables.<br>
  e.g.:- <br>
  main()<br>
  {<br>
  int i=500;<br>
  printf (&#8220;Address of i = %u&#8221;, &amp;i);<br>
  printf (&#8220;\n Value of i = %d&#8221;, i);<br>
  printf (&#8220;\n Value of i = %d&#8221;, *(&amp;i) );<br>
  }<br>
  will return, Address of i = 65496<br>
  Value of i = 500<br>
  Value of i = 500<br>
  The value of *(&amp;i) is the same as value of i. *(&amp;i) means the value 
  stored at the address of i, 500.</p>
<p>Declaring Pointer Variables<br>
  Pointers are declared using the indirection operator, *.<br>
  syntax : type *pointer-name;<br>
  Where type is any valid C data-type and pointer-name is a pointer variable. 
  The declaration tells the compiler that pointer-name is a variable used to store 
  the ad-dress of a value, of the given type. But pointer-name is of type pointer. 
  <br>
  e.g.:- int *j;<br>
  This declaration tells the compiler that j will be used to store the address 
  of an integer value. i.e., j points to an integer, or *j will return a value 
  of type int. j is not of type integer but it is a pointer to an integer value.<br>
  e.g.:- char *ch; float *s;<br>
  The declaration float *s does not mean that s is going to contain a floating-point 
  value. The meaning is, s is going to contain the address of a floating-point 
  value. Similarly char *ch means that ch is going to contain the address of a 
  character variable or the value at address stored in ch is going to be a char.</p>
<p>Assigning Values to Pointers<br>
  Values can be assigned to pointer variables through the reference operators 
  and the assignment statement. <br>
  Syntax: pointer-name = &amp;variable-name;<br>
  e.g.:- int i = 500;<br>
  int *j;<br>
  j = &amp;i;<br>
  i j<br>
  500 ? 65496<br>
  65496 65498<br>
  Since j is also a variable it&#8217;s address also can be printed using prefixing 
  j with the &amp; operator. i.e., &amp;j. The addresses are always whole numbers 
  and it should be printed using the %u conversion character.</p>
<p><br>
  e.g.:- <br>
  main()<br>
  {<br>
  int i = 500;<br>
  int *j;<br>
  j = &amp;i;<br>
  printf (&#8220;Address of i = %u&#8221;, &amp;i);<br>
  printf (&#8220;\n Address of i = %u&#8221;, j);<br>
  printf (&#8220;\n Address of j = %u&#8221;, &amp;j);<br>
  printf (&#8220;\n Value of j = %u&#8221;, j);<br>
  printf (&#8220;\n Value of i = %d&#8221;, i);<br>
  printf (&#8220;\n Value of i = %d&#8221;, *(&amp;i) );<br>
  printf (&#8220;\n Value of i = %d&#8221;, *j);<br>
  printf (&#8220;\n Value of j = %u&#8221;, *(j));<br>
  printf (&#8220;\n Value of i = %d&#8221;, *(*(&amp;j)));<br>
  }<br>
  Multiple Indirection<br>
  It is possible to have a pointer point to another pointer that points to the 
  target value. This situation is called multiple indirection, pointer to pointer. 
  In the case of pointer to a pointer, the first pointer contains the address 
  of the second pointer, which points to the variable that contains the value.<br>
  Variable Pointer Pointer-to-pointer<br>
  I j k<br>
  500 ? 65496 ? 65498<br>
  65496 65498 65500<br>
  A variable that is a pointer to pointer can be declared by placing an additional 
  aster-isk in the front of the variable name.<br>
  e.g.:- int **k;<br>
  This tells that k is a pointer-to-pointer of type int. To access the target 
  values indi-rectly apply the indirection operator twice.<br>
  e.g.:- <br>
  main()<br>
  {<br>
  int i = 500;<br>
  int *j, **k;<br>
  j = &amp;i;<br>
  k = &amp;j;<br>
  printf (&#8220;Address of i = %u&#8221;, &amp;i);<br>
  printf (&#8220;\n Address of i = %u&#8221;, j);<br>
  printf (&#8220;\n Address of i = %u&#8221;, *k);<br>
  printf (&#8220;\n Address of j = %u&#8221;, &amp;j);<br>
  printf (&#8220;\n Address of j = %u&#8221;, k);<br>
  printf (&#8220;\n Address of k = %u&#8221;, &amp;k);<br>
  printf (&#8220;\n Value of j = %u&#8221;, j);<br>
  printf (&#8220;\n Value of k = %u&#8221;, k);<br>
  printf (&#8220;\n Value of i = %d&#8221;, i);<br>
  printf (&#8220;\n Value of i = %d&#8221;, *(&amp;i) );<br>
  printf (&#8220;\n Value of i = %d&#8221;, *j);<br>
  printf (&#8220;\n Value of i = %u&#8221;, **k);<br>
  }<br>
  Call by value and Call by reference<br>
  Functions communicate with each other by passing arguments. Arguments can generally 
  be passed to functions in one of the two ways.<br>
  i) Sending the values of the arguments (Call by value)<br>
  ii) Sending the addresses of the arguments (Call by Reference)<br>
  Call by Value<br>
  When the arguments of a function are passed by value, a copy of the value con-tained 
  in the actual arguments is sent from the calling routine to the formal argu-ments 
  of the called function, rather than allowing the function direct access to the 
  memory location of the variables. So in Call by value the function uses a copy 
  of the actual arguments only. It cannot access the actual memory location of 
  the variable and therefore cannot change the value of the actual argument of 
  the calling function. Using this method, variables can be localised from within 
  the functions.<br>
  e.g.:- <br>
  # include &lt;stdio.h&gt;<br>
  void swap(int x, int y);<br>
  main()<br>
  {<br>
  int i = 10, j = 20;<br>
  clrscr();<br>
  printf(&#8220;Before Swapping&#8221;);<br>
  printf(&#8220;\n i = %d and j = %d&#8221;, i, j);<br>
  swap(i, j);<br>
  printf(&#8220;\n i = %d and j = %d&#8221;, i, j);<br>
  }<br>
  void swap(int x, int y)<br>
  {<br>
  int t;<br>
  t = y;<br>
  y = x;<br>
  x = t;<br>
  }</p>
<p>Call by Reference<br>
  In Call by Reference the function is allowed access to the actual memory location 
  of the actual arguments of the calling routine. i.e., The address of actual 
  arguments are copied into formal arguments of the called function. Therefore 
  changes made to the formal arguments in the called function will change the 
  values of the actual argu-ments in the calling function.<br>
  e.g.:- <br>
  # include &lt;stdio.h&gt;<br>
  void swap(int *x, int *y);<br>
  main()<br>
  {<br>
  int i = 10, j = 20;<br>
  clrscr();<br>
  printf(&#8220;Before Swapping&#8221;);<br>
  printf(&#8220;\n i = %d and j = %d&#8221;, i, j);<br>
  swap(&amp;i, &amp;j);<br>
  printf(&#8220;\n i = %d and j = %d&#8221;, i, j);<br>
  }<br>
  void swap(int *x, int *y)<br>
  {<br>
  int t;<br>
  t = *y;<br>
  *y = *x;<br>
  *x = t;<br>
  }</p>
<p>Pointer Arithmetic<br>
  &#8211;, ++, &#8211; &#8211;, * and &amp; are all unary operators having the 
  same precedence of evalua-tion. When several of these unary operators appear 
  in an expression, the evaluation takes place from right to left.<br>
  e.g.:-<br>
  int i = 500;<br>
  int *ptr;<br>
  ptr = &amp;i;<br>
  ++ ptr or ptr++ Points to the next integer after i.<br>
  &#8211; &#8211;ptr or ptr&#8211; &#8211; Points to the integer previous to i.<br>
  ptr + j Points to the jth integer after i.<br>
  ptr &#8211; j Points the jth integer before i.<br>
  ++*ptr or (*ptr)++ Will increment i by 1(one).<br>
  *++ptr Will fetch the value of the next integer after i.<br>
  *ptr++ Will print the contents of i and increments the ptr by 1(one) which will 
  point to the next integer after i.</p>
<p></p>
<p>Pointer Comparison<br>
  Comparison between the two pointer variables is possible if they both point 
  to vari-ables of the same type. Consider ptra and ptrb that point to data elements 
  a and b respectively of same type. Then,<br>
  ptra &lt; ptrb Returns true, if a is stored before b in memory<br>
  ptra &gt; ptrb Returns true, if a is stored after b <br>
  ptra &lt;= ptrb Returns true, if a is stored before b or ptra and ptrb both 
  are point to the same location<br>
  ptra &gt;= ptrb Returns true, if a is stored after b or ptra and ptrb both are 
  point to the same location<br>
  ptra = = ptrb Returns true, if both pointers are point to the same location<br>
  ptra != ptrb Returns true, if both pointers point to the different data elements 
  but of same type<br>
  ptra = = null Returns true if ptra is assigned NULL</p>
<p>Passing Pointers (Addresses) to Functions<br>
  When a pointer is passed to a function as argument address of a data item is 
  passed to the function making it possible to access the contents of that address 
  from within the function. This method enables a two-way transfer of data between 
  the calling routine and the called function.<br>
  Formal arguments of a function which are pointers are preceded by an asterisk 
  (*) indicating them to be pointers. Function declarations (prototypes) containing 
  pointers must also contain an asterisk (*). Actual pointer arguments in a function 
  call must either be declared pointers or referenced variables. (e.g.:- &amp;var)<br>
  e.g.:-<br>
  main()<br>
  {<br>
  int i, *ptr, j;<br>
  ptr = &amp;i;<br>
  ............<br>
  function(ptr, &amp;j);<br>
  ............<br>
  }<br>
  function(int *i, int *j)<br>
  {<br>
  ..........<br>
  return;<br>
  }</p>
<p></p>
<p>Pointers and Arrays<br>
  The name of an array written without the indices is a pointer-constant, which 
  points to the beginning, (zeroth element) of the array. The array name is a 
  pointer whose value is fixed by the compiler, depending on where the array is 
  stored in memory. The value of pointer constant cannot be changed in the program. 
  But this value can be assigned to a pointer variable.<br>
  e.g.:-<br>
  int num[12], *ptr;<br>
  ptr = num;<br>
  OR<br>
  ptr = &amp;num[0];<br>
  Here the array name num, which is a pointer-constant, is assigned to the pointer 
  variable ptr. Both the array name num and ptr point to the first element of 
  array.<br>
  ptr? <br>
  num ? - - - - - - - - - - - <br>
  &amp;num[0]? &amp;num[10]? &amp;num[11]?<br>
  e.g.:-<br>
  main()<br>
  {<br>
  int num[10], *ptr, *pa;<br>
  ptr = num;<br>
  pa = &amp;num[0];<br>
  printf(&#8220;The array starts at &#8220;);<br>
  printf(&#8220;\n %u ------%u&#8221;, ptr, pa);<br>
  getch();<br>
  }<br>
  Q1) Write a program to print the numbers stored in an array using pointers (i.e., 
  without array subscripting)<br>
  main()<br>
  {<br>
  int arr[10] = {1,2,3,4,5,6,7,8,9,10}, *ptr = arr, i;<br>
  for(i=0; i&lt;10; i++)<br>
  {<br>
  printf(&#8220;%d \n&#8221;, *ptr++);<br>
  }<br>
  getch();<br>
  }<br>
  Q2) Add 10 to each elements in an array of integers<br>
  main()<br>
  {<br>
  int arr[10] = {1,2,3,4,5,6,7,8,9,10}, *ptr = arr, i;<br>
  for(i=0; i&lt;10; i++)<br>
  {<br>
  *ptr++ += 10;<br>
  printf(&#8220;%d \n&#8221;, *(arr+i));<br>
  }<br>
  getch();<br>
  }<br>
  Q3) Display the contents array using pointers &amp; functions<br>
  main()<br>
  {<br>
  int arr[10] = {1,2,3,4,5,6,7,8,9,10}, i;<br>
  for(i=0; i&lt;10; i++)<br>
  {<br>
  print(&amp;arr[i]);<br>
  }<br>
  getch();<br>
  }<br>
  print(int *n)<br>
  {<br>
  printf(&#8220;%d \n&#8221;, *n);<br>
  }<br>
  Q4) Display the contents of array using functions &amp; pointers<br>
  main() print(int *n)<br>
  { {<br>
  int arr[10] = {1,2,3,4,5,6,7,8,9,10}, i; show(&amp;n);<br>
  for(i=0; i&lt;10; i++) }<br>
  { show(int **y)<br>
  print(&amp;arr[i]); {<br>
  } printf(&#8220;%d \n&#8221;, **y);<br>
  getch(); }<br>
  }<br>
  Passing Arrays to Functions (Using Pointers)<br>
  In order to pass an entire array to a function mention the address of the first 
  element (with subscript 0) of that array as the actual argument (The address 
  of the element with subscript zero is also called the base address. Also you 
  can mention the name of the array instead of the address of first element, because 
  the array name is a pointer-constant that contains the address of the fist element 
  of that array.<br>
  The formal argument in the function header of the called function must be a 
  pointer variable to accept the address.</p>
<p></p>
<p>e.g.(1) e.g.:- (2)<br>
  main() main() <br>
  { {<br>
  int arr[3] = {1,2,3}; int arr[3] = {1,2,3};<br>
  disp(arr); disp(&amp;arr[0]);<br>
  } }<br>
  disp(int *arr) disp(int *arr)<br>
  { {<br>
  int i; int i;<br>
  for(i=0; i&lt;3; i++) for(i=0; i&lt;3; i++)<br>
  { {<br>
  printf(&#8220;%d \n&#8221;, *arr); printf(&#8220;%d \n&#8221;, *arr);<br>
  arr++; arr++;<br>
  } }<br>
  getch(); getch();<br>
  } }</p>
<p>e.g.(3)<br>
  main()<br>
  {<br>
  char name[] = &#8220;KERALA &#8221;;<br>
  print(name);<br>
  }<br>
  print(char *name) print(char *name) <br>
  { { <br>
  printf(&#8220;%s \n&#8221;, name); int i; <br>
  for( ; *name != NULL; name++) printf(&#8220;%s \n&#8221;, name); <br>
  { for(i=0;*(name + i); i++)<br>
  printf(&#8220;%c \n&#8221;, *name); { <br>
  } printf(&#8220;%c \n&#8221;, *(name + i)); <br>
  getch(); } <br>
  } getch(); <br>
  }<br>
  print(char *name) <br>
  { <br>
  printf(&#8220;%s \n&#8221;, name);<br>
  while(*name) <br>
  { <br>
  printf(&#8220;%c \n&#8221;, *name);<br>
  name++; } <br>
  getch(); <br>
  } </p>
<p>More than One Dimension<br>
  Columns<br>
  0 1 2 3 <br>
  0 p+0? 10 20 30 40 <br>
  Rows 1<br>
  p+1? 50 60 70 80 <br>
  2<br>
  p+2? 90 91 92 93 </p>
<p> *(p+2)+0 *(p+1)+2 *(*(p+1)+2)<br>
  p ? pointer to first row<br>
  p + i ? pointer to ith row<br>
  *(p + i) ? pointer to first element in the ith row<br>
  *(p + i)+j ? pointer to jth element in the ith row<br>
  *(*p+ i)+j) ? value stored in the jth element of ith row [i.e., cell(i, j) ]<br>
  A two-dimensional array is nothing but a collection of a number of one-dimensional 
  arrays placed one after another. In memory whether it is a one-dimensional or 
  it is a two-dimensional the elements are stored in one continuous chain.<br>
  ? row 1 ? ? row 2 ? ? row 3 ?<br>
  10 20 30 40 50 60 70 80 90 91 92 93<br>
  6000 6002 6004 6006 6008 6010 6012 6014 6016 6018 6020 6022<br>
  &#8216;C&#8217; treats parts of arrays as arrays. i.e., each row of a two dimensional 
  array can be treated as a one dimensional array.<br>
  Thus, int arr[3][4];<br>
  Can be thought of as setting up a one-dimensional array of three elements, each 
  of which is a one-dimensional array, 4 elements long. By default we can refer 
  to an element of a one-dimensional array using a single subscript. Similarly, 
  if we imagine arr to be a one-dimensional array, then we can refer to its zeroth 
  element as arr[0], the next element as arr[1] and so on.<br>
  If we execute the statement,<br>
  printf(&#8220;%u&#8221;, arr[0] );<br>
  We expect the 0th element to get printed and in the case of a two-dimensional 
  array the 0th element is a one-dimensional array. By default by mentioning a 
  one-dimensional array gives its base address. Therefore the printf() print the 
  base ad-dress of the 0th one-dimensional array. Similarly arr[1] would give 
  the address of 1st one-dimensional array.<br>
  e.g.:- main()<br>
  {<br>
  int arr[3][4]={<br>
  {10,20,30,40},<br>
  {50,60,70,80},<br>
  {90,91,92,93}<br>
  };<br>
  int i, j;<br>
  for(i=0; i&lt;3;i++)<br>
  printf(&#8220;\n Address of %d th one-dimensional array = %u &#8220;, i, arr[i] 
  );<br>
  }<br>
  Will print,<br>
  Address of 0th one-dimensional array = 6000<br>
  Address of 1th one-dimensional array = 6008<br>
  Address of 2th one-dimensional array = 6016<br>
  Once the two-dimensional array is declared, there onwards arr is treated as 
  pointer to zeroth element of the two-dimensional array. Hence the expression 
  (arr+0) gives the address of the zeroth element of the two-dimensional array. 
  Therefore the ex-pression *(arr+0) give the value of zeroth element. But the 
  zeroth element of two-dimensional array is a one-dimensional array and on mentioning 
  one-dimensional array we get its base address. Hence *(arr+0) gives the address 
  of the zeroth one-dimensional array. i.e., arr[0] = *(arr+0) = 6000. Similarly 
  arr[1] = *(arr+1) = base address of the 1st one-dimensional array, 6008. Therefore 
  the expression arr[i] or *(arr+i) would give the base address of ith one-dimensional 
  array.<br>
  Now, we have to access each individual elements of a row. For example we want 
  to refer to the element arr[2][1] using pointers. From the above example we 
  got the address of 2nd one-dimensional array (arr[2]) as 6016. Therefore (6016+1) 
  will give the address 6018 and the value at this address can be obtained by 
  using the ex-pression *(arr[2]+1). But using the concept one-dimensional array 
  arr[2] is the same as *(arr+2). Therefore *(arr[2]+1) is the same as *(*(arr+2)+1). 
  i.e., arr[2][1], *(arr[2]+1) and *(*(arr+2)+1) all are refer to the same element.<br>
  Type definition<br>
  &#8216;C&#8217; allows user-defined data-types with the help of typedef keyword.<br>
  syntax: typedef type new_name;<br>
  Where type refers to an existing data type.<br>
  Using this method users are not actually creating a new data type, but just 
  defining a new name for an existing data type.<br>
  e.g.:- typedef float marks;<br>
  This statement tells the compiler to recognise marks as another name for float. 
  This can be later used to declare variables.<br>
  e.g.:- marks arr[10];<br>
  Here arr[10] is a floating point array of type marks, which is another name 
  for float. The main advantage of typedef is that we can create meaningful data 
  type names for increasing the readability of the program.</p>
<p><br>
  Type Conversion<br>
  Automatic Type Conversion: &#8216;C&#8217; allows mixing of constants and variables 
  of differ-ent types in an expression. But during the evaluation it keeps the 
  rules of type conversion. i.e., if the operands are of different types, the 
  lower type is automatically converted to the higher type before the operation 
  proceeds. The result is of the higher type. The order is as shown below, the 
  higher is first and the lower is last.<br>
  long double<br>
  double<br>
  float<br>
  unsigned long int<br>
  long int<br>
  unsigned int<br>
  int<br>
  All char are automatically converted to int. By default &#8216;C&#8217; converts 
  all floating-point operands to double precision. The final result of an expression 
  is converted to the type of the variable on the left of the assignment sign 
  before assigning the value to it.<br>
  Type Casing: Casing is a temporary conversion of a data object from one type 
  to another. Casts utilise parenthesised data type to convert the representation 
  of the object that the cast immediately precedes. Only basic data types of char, 
  int, float, double, enum and pointers are used with casting.<br>
  syntax: (type) expression<br>
  Where type is one of the fundamental data types in &#8216;C&#8217;. The expression 
  can be constant, variable or an expression (calculation).<br>
  e.g.: - <br>
  printf(&#8220;%d&#8221;, (int) 7.42);<br>
  printf(&#8220;%f&#8221;, (float)10/8 );<br>
  printf(&#8220;%d&#8221;, (int) (10.3+4.8) );<br>
  printf(&#8220;%f&#8221;, pow((double)2, (double)3) );<br>
  Q) Write a program to calculate the result of the following expression,<br>
  1/1+1/2+1/3+&#8230;+1/10.<br>
  main()<br>
  {<br>
  float sum=0;<br>
  int n;<br>
  for(n=1;n&lt;10;n++)<br>
  sum = sum+1/(float)n;<br>
  printf(&#8220;Result = %f&#8221;, sum);<br>
  }<br>
  Will print, Result = 2.9290.<br>
  Casts are useful when working with pointers. The concept that a pointer variable 
  contains the address of another object, whose value may be retrieved using indirec-tion 
  (*) is declared on the fact that a pointer variable is not just an address but 
  it also points to a particular type of data representation. Just as normal variables 
  may be cast to alter the form of representation, pointer variables may be cast 
  to alter the interpretation of the variable type being pointed to.<br>
  Dynamic Memory Allocation<br>
  &#8216;C&#8217; language requires the number of elements in an array to be specified 
  at the compile time. When the program compiled the space for that specified 
  no. of ele-ments of the array is reserved in the memory. Once specific memory 
  locations have been reserved for a variable/array, these locations are fixed, 
  whether they are used or not. The memory allocated at the compile time is released 
  only when the pro-gram/function terminates and if the initially given array 
  size is wrong, there is a chance of failure of the program or wastage of memory 
  space.<br>
  &#8216;C&#8217; allows specifying an array&#8217;s size at run time. i.e., at 
  the time of execution, or when the program needed. The process of allocating 
  memory at run time is known as dynamic memory allocation. Under dynamic allocation 
  scheme storage space is allocated to a program and released back to the system 
  (OS) while the program is running.<br>
  In &#8216;C&#8217; dynamic memory allocation is accomplished by using four library 
  functions known as memory management functions.<br>
  Arrays can be defined as pointer variables since an array name is actually a 
  pointer to the first element of the array.<br>
  e.g.:- int *d; char *c; etc<br>
  But no fixed block of memory is allocated to pointer variables used as arrays. 
  In order to use a pointer variable as an array, it is necessary to allocate 
  memory to it before the array elements are processed. This can be done by memory 
  management functions.<br>
  Memory management Functions<br>
  malloc()<br>
  syntax: void *malloc(size);<br>
  malloc() reserves a continuous block of memory of specified size (in bytes) 
  and returns a pointer to the newly allocated block&#8217;s first byte (base 
  address) or NULL if not enough space exists for the new block. Also if the size 
  is zero, it returns NULL.<br>
  malloc() returns a pointer of type void, therefore you can assign it to any 
  type of pointer after type casting.<br>
  i.e., ptr = (type *) malloc(size);<br>
  e.g.:-<br>
  int *d;<br>
  d = (int *) malloc(10 * sizeof(int) );<br>
  The above example allocates a memory of 10 times the size of int type and returns 
  the base address of the allocated memory block to the pointer d.<br>
  Sample Program: Write a program to store marks of 10 students<br>
  # include &lt;stdio.h&gt;<br>
  # include &lt;stdlib.h&gt;<br>
  main()<br>
  {<br>
  int *p, i;<br>
  p = (int *) malloc( 10 * sizeof(int) );<br>
  if(p == NULL)<br>
  {<br>
  printf(&#8220;Not enough Memory&#8221;);<br>
  return;<br>
  }<br>
  for(i=0; i&lt;10; i++)<br>
  {<br>
  printf(&#8220; Enter mark %d : &#8221;, i+1);<br>
  scanf(&#8220;%d&#8221;, p);<br>
  p++;<br>
  }<br>
  p &#8211; =10;<br>
  for(i=0; i&lt;10; i++)<br>
  {<br>
  printf(&#8220; %d : &#8221;, *p);<br>
  p++;<br>
  }<br>
  }<br>
  calloc()<br>
  syntax: void *calloc(n, bolck_size);<br>
  calloc() is used to allocate memory space at run time for storing derived data 
  types such as arrays and structures. While malloc() allocates a single block 
  of memory, calloc() allocates multiple blocks of memory. calloc() also initialises 
  all the elements by a value of zero.<br>
  ptr = (type *) calloc( n, size);<br>
  Allocates continuous space for n blocks of given size. All bytes are initialised 
  to zero and a pointer to the base address of the allocated block is returned. 
  If there is not enough space, a NULL pointer is returned.<br>
  e.g.:-<br>
  int *x;<br>
  x = (int *) calloc( 3, 4*sizeof(int) );<br>
  Sample Program: To accept numbers to a 3x4 matrix<br>
  main()<br>
  {<br>
  int *x, i, j;<br>
  x = (int ) calloc( 3, 4*sizeof(int) );<br>
  for( i=0; i&lt;12; i++)<br>
  {<br>
  printf(&#8220; Enter Number %d : &#8221;, i+1);<br>
  scanf(&#8220;%d&#8221;, x); x++;<br>
  }<br>
  x&#8211; =12;<br>
  for(i=0; i&lt;3; i++)<br>
  {<br>
  for(j=0; j&lt;4; j++)<br>
  {<br>
  printf(&#8220;%d \t&#8221;, *(*(x+i*3)+j) );<br>
  }<br>
  printf(&#8220;\n&#8221;);<br>
  }<br>
  }<br>
  Q) Write a program to accept 5 names and print those names. (use calloc() )<br>
  # include &lt;stdio.h&gt;<br>
  # include &lt;stdlib.h&gt;<br>
  main()<br>
  {<br>
  char *names;<br>
  int x;<br>
  names = (char *) calloc(5, 21*sizeof(char));<br>
  if(names == NULL)<br>
  {<br>
  printf(&#8220;Not enough Memory&#8221;); exit(-1);<br>
  }<br>
  for(x=0; x&lt;5; x++)<br>
  {<br>
  printf(&#8220;enter name %d : &#8221;, x+1);<br>
  scanf(&#8220;%20s&#8221;, (names+x*21));<br>
  }<br>
  names &#8211; = 5*21;<br>
  for(x=0; x&lt;5; x++)<br>
  printf(&#8220;%d \t %s \n&#8221;, x+1, (names+x*21) );<br>
  getch();<br>
  }<br>
  free()<br>
  syntax: free(pointer_to_memory_block);<br>
  Compile time storage of a variable is allocated and released from the memory 
  by the system in accordance with its storage class. But the memory allocated 
  using the dynamic memory allocation functions, at run time will not be released 
  from the memory even if it is not required. We can release the block of memory 
  allocated by malloc() or calloc() functions using the free().<br>
  e.g.:- free(ptr);<br>
  Where ptr is a pointer to a memory block which has been created by malloc() 
  or calloc().<br>
  Realloc()<br>
  syntax: realloc(ptr, new_size);<br>
  realloc() is used to increase or decrease the previously allocated block of 
  memory to new_size ( in bytes) and returns the address of the reallocated block 
  which can be different than the original address. The contents of the old block 
  will be moved to the new block if the address of the reallocated block changes 
  from the original. i.e., the old data will be the same even after the reallocation 
  of memory. If the function is unsuccessful in locating additional space, it 
  returns a NULL pointer and the original block is freed (lost).<br>
  Sample Program:<br>
  # include &lt;stdio.h&gt;<br>
  # include &lt;stdlib.h&gt;<br>
  main()<br>
  {<br>
  char *place;<br>
  if((place = (char *) malloc(10)) == NULL)<br>
  {<br>
  printf(&#8220;Not enough Memory&#8221;);<br>
  exit(-1);<br>
  }<br>
  strcpy(place, &#8220;Trichur&#8221;);<br>
  if((place = (char *) realloc(place, 20)) == NULL)<br>
  {<br>
  printf(&#8220;Not enough Memory, data lost&#8221;);<br>
  exit(-1);<br>
  }<br>
  printf(&#8220;Contents of place = %s \n&#8221;, place);<br>
  strcpy(place, &#8220;Thiruvananthapuram&#8221;);<br>
  printf(&#8220;Contents of place = %s \n&#8221;, place);<br>
  free(place);<br>
  }<br>
  Structures in C<br>
  A structure is a collection of one or more variables, possibly of different 
  types, grouped together under a single name for convenient handling. Structures 
  are called records in many languages like COBOL, FoxPro etc. Structures help 
  to organise complicated data, particularly in large programs, because they permit 
  a group of related variables to be treated as a unit instead of as separate 
  variables. for exam-ple, a student record&#8217;s details like Rollno, name, 
  house, pin, sex etc. or employee details like employee no., name, salary, sex 
  etc.<br>
  Structure, which is a data structure whose individual data element can differ 
  in type. A data structure may contain variables of basic data types, arrays, 
  pointers and other data structures except the structure itself. The individual 
  structure elements are called members of the structure.<br>
  Defining a Structure<br>
  A structure must be defined in terms of its individual members. Structure declaration 
  starts with the keyword struct followed by a name for the structure called structure 
  tag. The various fields ie., members are declared within a block of code enclosed 
  by braces. the member declaration is as the same as that of an ordinary variable 
  decla-ration. After the closing brace of the block a semicolon must terminate 
  the structure declaration.<br>
  syntax: <br>
  struct tag<br>
  {<br>
  type member-1;<br>
  type member-2;<br>
  ........................<br>
  type member-n;<br>
  };<br>
  The member names within a structure must be unique through member names can 
  be the same as the variable name defined outside of the structure. The rules 
  of forming a tag name and individual member names are the same as for other 
  vari-ables. the member can not be initialised within a structure declaration. 
  Declaration tells only a model (template) of type struct tag and no space is 
  allocated in the memory. Space is allocated only when a structure variable is 
  declared.<br>
  e.g.:- <br>
  struct emp<br>
  {<br>
  int emp_no;<br>
  char name[20];<br>
  float salary;<br>
  char sex;<br>
  };<br>
  Structure Variable Declaration<br>
  syntax: struct tag variable1, variable2;<br>
  Where variable1, variable2 are variables of type struct tag.<br>
  e.g.:- struct emp salesman, officer;<br>
  Where salesman and officer are variables of type struct emp.<br>
  It is also possible to combine structure declaration and variable declaration 
  in one statement.<br>
  syntax: struct tag<br>
  {<br>
  type member-1;<br>
  type member-2;<br>
  ........................<br>
  type member-n;<br>
  } variable1, variable2;<br>
  The tag is optional in this case.<br>
  e.g.:- <br>
  struct emp<br>
  {<br>
  int emp_no;<br>
  char name[20];<br>
  float salary;<br>
  char sex;<br>
  } salesman, officer;<br>
  Referencing Fields (members) of Structure<br>
  Referencing a field means accessing its contents. A structure field is referred 
  to by writing the name of the structure variable followed by a dot(.), followed 
  by the name of the field(member).<br>
  syntax: structure_vriable_name.member_name<br>
  Where dot(.) is called the structure member operator, which connects the struc-ture_variable 
  name and the member_name.<br>
  e.g.:-<br>
  salesman.salary = 2345.23;<br>
  officer.sex = &#8216;M&#8217;;<br>
  strcpy(officer.name, &#8220;KERALA &#8221;);<br>
  salesman.name[0] = &#8216;A&#8217;;<br>
  officer.emp_no++;<br>
  officer.name[0] = toupper(officer.name[0]);<br>
  ptr = &amp;officer.salary;<br>
  Initialisation of Structure Variables<br>
  The initialisation is done by giving an equal sign after the variable name, 
  followed by a list of values for the members (fields) enclosed in a pair of 
  braces. The closing brace is followed by a semicolon. Initialisation can be 
  done only at the time of struc-ture variable declaration and not at the time 
  of execution.<br>
  e.g.:- struct emp officer = { 420, &#8220;KERALA &#8221;, 1200.50, &#8216;M&#8217; 
  };<br>
  Copying of structure Variables<br>
  Although structure is a derived data type, structure variable is a valid operand 
  for the assignment operator. A structure variable can be copied into another 
  variable of the same structure type, by the assignment operator. <br>
  For example, if the contents of officer1 were to be copied into officer2,<br>
  officer2 = officer1;</p>
<p>To copy the content of one structure variable into another you can also copy 
  individ-ual members of the entire structure.<br>
  For example if the contents of officer1 were to be copied into officer2,<br>
  officer2.mp_no = officer1.emp_n;<br>
  strcpy(oficer2.name, officer.name);<br>
  officer2.salary = officer1.salary;<br>
  officer2.sex = officer1.sex;<br>
  Another method would be to use the memcpy()<br>
  syntax: memcpy( &amp;dest, &amp;source, n_bytes);<br>
  This function copies n_bytes starting from the address of source to a block 
  of n_bytes starting from the address of destination. The size of the structure, 
  i.e., n_bytes can be obtained by using the sizeof() operator.<br>
  e.g.:- memcpy(&amp;officer2, &amp;officer1, sizeof(struct emp) );<br>
  Arrays of Structure<br>
  To declare an array of structures first define a tructure and then declare an 
  array variable of that typr. For example, to declare a 10 element array of structures 
  of type struct emp that had been defined earlier,<br>
  struct emp employee[10];<br>
  Like all aray variables, array of structures begins subscripting at 0. The arry 
  name followed by its subscript enclosed in square brackets stands for an element 
  of that array.<br>
  To print the name of the second element in the array,<br>
  printf(&#8220;name of second employee : %s&#8221;, employee[1].name );<br>
  To copy the fifth element of the array to he seventh element,<br>
  memcpy(&amp;employee[6], &amp;employee[4], sizeof(struct emp) );<br>
  Initialisation of structure arrays<br>
  e.g.:- struct emp employee[3] = { { 101, &#8220;KERALA &#8221;, 7812, &#8216;M&#8217; 
  },<br>
  { 102, &#8220;Sunil&#8221;, 4352, &#8216;M&#8217; },<br>
  { 103, &#8220;Santhi&#8221;, 5412, &#8216;F&#8217; }<br>
  };<br>
  Each element of the array is initialised as if some structure variable is being 
  initial-ised. The whole list is then enclosed within braces to indicate that 
  the array is being initialised.<br>
  Structures within a Structure<br>
  In &#8216;C&#8217; the components of a structure can be anything but the structure 
  itself. There-fore we can have one structure within another to group the data 
  more meaningfully.<br>
  e.g.:- <br>
  struct sal<br>
  {<br>
  float basic;<br>
  float hra;<br>
  float da;<br>
  };<br>
  struct emp<br>
  {<br>
  int emp_no;<br>
  char name[20];<br>
  struct sal salary;<br>
  char sex;<br>
  };<br>
  struct emp emp1, emp2;<br>
  To access the name of emp1,<br>
  emp1.name<br>
  To access the basic of emp1,<br>
  emp1.salary.basic<br>
  To initialize, struct emp emp2 = { 1001, &#8220;KERALA &#8221;, {1000.45, 150, 
  435.55 }, &#8216;M&#8217; };<br>
  Passing Structures as Arguments to Functions (Call by Value)<br>
  A structure variable can be passed as an argument to another function. This 
  is a useful facility because it is used to pass groups of logically related 
  data items to-gether instead of passing them one by one. &#8216;C&#8217; also 
  supports to pass the members of a structure individually.<br>
  Q) Write a program to accept the details of 10 employees. The program should 
  print a report of all employees&#8217; details and the net salary.<br>
  # include &lt;stdio.h&gt;<br>
  struct sal<br>
  {<br>
  float basic;<br>
  float hra;<br>
  float da;<br>
  };<br>
  struct emp<br>
  {<br>
  int emp_no;<br>
  char name[20];<br>
  float salary;<br>
  char sex;<br>
  };<br>
  float total(struct sal salary);<br>
  main()<br>
  {<br>
  struct emp employee[10];<br>
  int i;<br>
  for( i=0; i&lt;10; i++)<br>
  {<br>
  printf(&#8220;Enter Employee Number : &#8220;); scanf(&#8220;%d&#8221;, &amp;employee[i].emp_no);<br>
  printf(&#8220;Enter Employee Name : &#8220;); scanf(&#8220;%s&#8221;, employee[i].name);<br>
  printf(&#8220;Enter Basic Salary : &#8220;); scanf(&#8220;%f&#8221;, &amp;employee[i].salary.emp_no);<br>
  printf(&#8220;Enter HRA : &#8220;); scanf(&#8220;%f&#8221;, &amp;employee[i].salary.hra);<br>
  printf(&#8220;Enter DA : &#8220;); scanf(&#8220;%f&#8221;, &amp;employee[i].salary.da);<br>
  printf(&#8220;Enter Sex : &#8220;); scanf(&#8220;%c&#8221;, &amp;employee[i].sex);<br>
  }<br>
  for( i=0; i&lt;10; i++)<br>
  { <br>
  float x;<br>
  x = total(employee[i].salary);<br>
  printf(&#8220;%d \t %s \t %f \t %f \t %f \t %f \n&#8221;, employee[i].emp_no, 
  employee[i].name, \<br>
  employee[i].salary.basic, employee[i].salary.hra, employee[i].salary.da, x);<br>
  }<br>
  }<br>
  float total(struct sal salary)<br>
  {<br>
  return(salary.basic + salary.hra + salary.da);<br>
  }<br>
  Pointers to Structures<br>
  &#8216;C&#8217; allows pointers to structures just as it allows pointers to 
  any other type of variable. Like other pointers we can declare structure pointers 
  by placing an indirection opera-tor in front of pointer variable name.<br>
  e.g.:- struct emp *emp_ptr;<br>
  There are two major uses for structure pointers, to generate a call by reference 
  call to a function and to create linked lists and other dynamic data structures 
  using &#8216;C&#8217;s dynamic memory allocation system.<br>
  To find the address of a structure variable, place the &amp; operator before 
  the variable name.<br>
  e.g.:- struct emp emp1, emp_ptr;<br>
  emp_ptr = &amp;emp1;<br>
  In order to access the elements (members) of a structure using a pointer to 
  that structure use the ? operator.<br>
  e.g.:- emp_ptr?sex = &#8216;F&#8217;;<br>
  is the same as<br>
  e.g.:- emp1.sex = &#8216;F&#8217;;<br>
  The ? is called the arrow operator, and consists of the minus sign followed 
  by the greater than sign.<br>
  The declaration of a pointer allocates space for the pointer and not what it 
  points to. Therefore it is necessary to make the pointer to point to a place 
  in memory contain-ing some legal address of that type.<br>
  e.g.:- emp_ptr = &amp;emp1;<br>
  Sometimes it is necessary that storage for a variable be allocated at the time 
  of execution as and when needed. This is done using C&#8217;s dynamic memory 
  allocation function malloc().<br>
  e.g.:- emp_ptr = (struct emp *) malloc(sizeof(struct emp));<br>
  ?The programmer can use the dot (.) operator to access the member of structure 
  pointer instead of using the arrow (?) operator, using the format, (*ptr).member. 
  For example to access the member salary, you can use (*emp_ptr).salary instead 
  of emp_ptr?salary. The parentheses around *emp_ptr are necessary because the 
  member operator (.) has a higher precedence than the indirection operator (*).</p>
<p>Q) Write a program to accept the details of 10 employees. The program should 
  print a report of all employees&#8217; details and the net salary. [Use pointer 
  to structure]<br>
  e.g.:- <br>
  # include &lt;stdio.h&gt;<br>
  struct sal<br>
  {<br>
  float basic;<br>
  float hra;<br>
  float da;<br>
  };<br>
  struct emp<br>
  {<br>
  int emp_no;<br>
  char name[20];<br>
  struct sal salary;<br>
  char sex;<br>
  };<br>
  float total(struct sal salary);<br>
  main()<br>
  {<br>
  struct emp employee[10], *emp_ptr, *temp;<br>
  int i;<br>
  emp_ptr = employee; temp = emp_ptr;<br>
  for( i=0; i&lt;10; i++)<br>
  {<br>
  printf(&#8220;Enter Employee Number : &#8220;); scanf(&#8220;%d&#8221;, &amp;emp_ptr?emp_no);<br>
  printf(&#8220;Enter Employee Name : &#8220;); scanf(&#8220;%s&#8221;, emp_ptr?name);<br>
  printf(&#8220;Enter Basic Salary : &#8220;); scanf(&#8220;%f&#8221;, &amp;emp_ptr?salary.emp_no);<br>
  printf(&#8220;Enter HRA : &#8220;); scanf(&#8220;%f&#8221;, &amp;emp_ptr?salary.hra);<br>
  printf(&#8220;Enter DA : &#8220;); scanf(&#8220;%f&#8221;, &amp;emp_ptr?salary.da);<br>
  printf(&#8220;Enter Sex : &#8220;); scanf(&#8220;%c&#8221;, &amp;emp_ptr?.sex);<br>
  emp_ptr++;<br>
  }<br>
  emp_ptr = temp;<br>
  for( i=0; i&lt;10; i++)<br>
  { <br>
  float x;<br>
  x = total(emp_ptr?salary);<br>
  printf(&#8220;%d \t %s \t %f \t %f \t %f \t %f \n&#8221;, emp_ptr?emp_no, emp_ptr?.name, 
  \<br>
  emp_ptr?salary.basic, emp_ptr?salary.hra, emp_ptr?salary.da, x);<br>
  emp_ptr++;<br>
  }<br>
  }<br>
  float total(struct sal salary)<br>
  {<br>
  return(salary.basic + salary.hra + salary.da);<br>
  }<br>
  Passing Structure Pointers as Arguments to Functions (Call by reference)<br>
  Structure pointers can be passed to functions by declaring the formal parameters 
  of the function as a structure pointer and at the time of calling the function, 
  a pointer to the structure or the address of a structure variable is passed 
  to the function. Using this method i.e., Call by Reference the elements of the 
  structure can be modified in the function.<br>
  Type definition of Structures: The typedef feature is useful when defining struc-tures, 
  since it eliminates the need to repeatedly write struct tag whenever a struc-ture 
  is referenced.<br>
  syntax: <br>
  typedef struct <br>
  {<br>
  type member-1;<br>
  type member-2;<br>
  ........................<br>
  type member-n;<br>
  } new_type;<br>
  Where new_type is the user-defined structure type and not a structure variable. 
  Structure variables can now be defined in terms of the new data type.<br>
  e.g.:- <br>
  typedef struct <br>
  {<br>
  int emp_no;<br>
  char name[20];<br>
  float salary;<br>
  char sex;<br>
  } employee;<br>
  employee x, y;<br>
  Where employee is the new data type and x and y are variables of type employee.<br>
  Q) Write a program to accept the details of 10 employees. The program should 
  print a report of all employees&#8217; details and the net salary. [Use dynamic 
  memory alloca-tion, call by reference and pointer to structure]<br>
  e.g.:- <br>
  # include &lt;stdio.h&gt;<br>
  typedef struct<br>
  {<br>
  float basic;<br>
  float hra;<br>
  float da;<br>
  } sal;<br>
  struct emp<br>
  {<br>
  int emp_no;<br>
  char name[20];<br>
  sal salary;<br>
  char sex;<br>
  };<br>
  typedef struct emp empl;<br>
  float total(sal *salary);<br>
  main()<br>
  {<br>
  empl *emp_ptr, *ptr;<br>
  int i;<br>
  emp_ptr = (empl *) malloc(10 * sizeof(empl) );<br>
  ptr = emp_ptr;<br>
  if(ptr == NULL)<br>
  {<br>
  printf(&#8220; Not enough Memory &#8220;);<br>
  return;<br>
  }<br>
  for( i=0; i&lt;10; i++)<br>
  {<br>
  printf(&#8220;Enter Employee Number : &#8220;); scanf(&#8220;%d&#8221;, &amp;emp_ptr?emp_no);<br>
  printf(&#8220;Enter Employee Name : &#8220;); scanf(&#8220;%s&#8221;, emp_ptr?name);<br>
  printf(&#8220;Enter Basic Salary : &#8220;); scanf(&#8220;%f&#8221;, &amp;emp_ptr?salary.emp_no);<br>
  printf(&#8220;Enter HRA : &#8220;); scanf(&#8220;%f&#8221;, &amp;emp_ptr?salary.hra);<br>
  printf(&#8220;Enter DA : &#8220;); scanf(&#8220;%f&#8221;, &amp;emp_ptr?salary.da);<br>
  fflush(stdin);<br>
  printf(&#8220;Enter Sex : &#8220;); scanf(&#8220;%c&#8221;, &amp;emp_ptr?.sex);<br>
  emp_ptr++;<br>
  }<br>
  emp_ptr = ptr;<br>
  for( i=0; i&lt;10; i++)<br>
  { <br>
  float x;<br>
  x = total(&amp;emp_ptr?salary);<br>
  printf(&#8220;%d \t %s \t %f \t %f \t %f \t %f \n&#8221;, emp_ptr?emp_no, emp_ptr?.name, 
  \<br>
  emp_ptr?salary.basic, emp_ptr?salary.hra, emp_ptr?salary.da, x);<br>
  emp_ptr++;<br>
  }<br>
  }<br>
  float total(sal *salary)<br>
  {<br>
  return(salary?basic + salary?hra + salary?da);<br>
  }<br>
  Self-Referential Structures<br>
  &#8216;C&#8217; allows to include within a structure one member that is a pointer 
  to the parent structure type. <br>
  syntax: <br>
  struct tag<br>
  {<br>
  type member-1;<br>
  type member-2;<br>
  ........................<br>
  type member-n;<br>
  struct tag *ptr;<br>
  };<br>
  Where ptr refers to the name of a pointer variable. Thus the structure of type 
  tag will contain a member that points to another structure of type tag. Such 
  structures are known as self-referential structures.<br>
  Self-referential structures are very useful to create linked data structures 
  like linked lists. Linked lists are used to create arrays of unknown size in 
  memory. i.e., the size of linked list can grow or shrink during the execution 
  of a program, because a linked list is a dynamic data structure. But array&#8217;s 
  size is fixed at the time of compilation. Linked lists allow items to be inserted 
  and deleted quickly and easily.<br>
  Linked lists can be circularly, singly or doubly linked. A singly linked list 
  contains a link to the next data item. Each data item called node consists of 
  a structure that includes information fields and a link pointer and the last 
  item&#8217;s link pointer points to the NULL, to terminate the linked list.</p>
<p>FILE HANDLING IN C<br>
  The 'C' file system works with a wide variety of devices including keyboard, 
  monitor, printers, disk drives etc. Even though all these devices are very different 
  from each other. The buffered file system transforms each device into a logical 
  device called stream. All streams act similarly and hence there is no difficulty 
  in handling these different types of devices. The functions used are all common 
  for any device.<br>
  Streams and Files<br>
  The &#8216;C&#8217; I/O system provides an interface to the 'C' programmer independent 
  of the actual device being accessed. This interface is not actually a file but 
  an abstract representation of the device. This abstract interface is known as 
  a stream and the actual device is called the file. There are two types of streams, 
  the text and binary streams.<br>
  TEXT STREAMS<br>
  A text stream is a sequence of characters. The text streams can be organised 
  into lines terminated by a Newline character. Newline characters are optional 
  in the last line as this line can be terminated using the end-of-file mark. 
  In a text stream, certain characters may undergo translations as required by 
  the host environment (operating system) for example, a Newline (\n) can be converted 
  to a carriage return (&#8216;\r&#8217;) and linefeed pair. Therefore, there 
  may not be a one to one relationship be-tween the characters read or written 
  and those on the external device. Also because of translations, the number of 
  characters read or written may not be same as that on the actual device. Under 
  DOS, the character Ctrl-Z (ASCII 26) is used in text streams indicates the end-of-file.<br>
  BINARY STREAMS <br>
  A binary stream is a sequence of bytes with a one-to-one correspondence to those 
  in the external device. There are no character translations as in the text streams. 
  The number of bytes read or written is the same as the number on the actual 
  device. Binary streams are a sequence of bytes, which do not have any flags 
  to indicate the end of file or end of record. End-of-file is determined by the 
  size of the file.<br>
  FILE POINTERS<br>
  A file pointer is a pointer to information that defines various details about 
  the file, like filename, status, current position of file pointer, etc. i.e., 
  the file pointer identifies a specific disk file and is used by the associated 
  stream to direct the opera-tion of the buffered I/O functions. A file pointer 
  is a pointer variable to the data type FILE. FILE is a derived data type and 
  its structure is defined in stdio.h.<br>
  In order to read or write files the program needs to use file pointers.<br>
  E.g. :- FILE *fp, *fp1, fp2;<br>
  OPENING STREAMS USING fopen()<br>
  The fopen() opens a stream for use and links a file with that stream and returns 
  the file pointer associated with that file. If an error occurs when it is trying 
  to open a file then fopen() returns a NULL pointer. The prototype of fopen() 
  is as follows,<br>
  FILE fopen(char *filename, char *mode);<br>
  where filename is a pointer to string of characters that make up a valid filename 
  and may include a path specification and the mode determines how the file will 
  be opened. The mode can be one of the following,<br>
  r Open a text file for reading<br>
  w Create a text file for writing<br>
  a Append to a text file<br>
  rb Open a binary file for reading<br>
  wb Create a binary file for writing<br>
  ab Append to a binary file<br>
  r+ Open a text file for read/write<br>
  w+ Create a text file for read/write<br>
  a+ Open/`Create a text file for read/write<br>
  rb+ Open a binary file for read/write<br>
  wb+ Create a text file for read/write<br>
  ab+ Open a binary file in append mode for read/write</p>
<p>Using w mode removes the file if already present. Therefore it is better to 
  check for existence of the file before opening in the write mode. If the mode 
  is a the file is opened with the current contents safe. If the specified file 
  does not exist, a file created with the specified filename.<br>
  e.g.:- <br>
  main()<br>
  {<br>
  FILE *fp;<br>
  &#8230;&#8230;&#8230;<br>
  fp=fopen(&quot;test&quot;,&quot;w&quot;);<br>
  if(fp==NULL)<br>
  {<br>
  printf('Cannot open the file&quot;);<br>
  exit(1);<br>
  }<br>
  &#8230;&#8230;&#8230;<br>
  }<br>
  If a file is opened for read/write operations, it will not be erased if it exists. 
  If it does not exist, it will be created.</p>
<p>CLOSING STREAMS<br>
  Closing a stream frees various system resources and flushes out the associ-ated 
  buffers that prevents loss of data when writing to a disk.<br>
  fclose()<br>
  prototype : int fclose(FILE *stream);<br>
  Where stream is the file pointer. The function returns an integer value, 0, 
  if success-ful else returns EOF.<br>
  fcloseall()<br>
  prototype : int fcloseall(void);<br>
  This function closes all open streams and returns the number of streams closed 
  or EOF if any error is detected.<br>
  e.g.:-<br>
  main()<br>
  {<br>
  int fcl;<br>
  &#8230;&#8230;.<br>
  fcl=fcloseall();<br>
  if(fcl= =EOF)<br>
  printf(&quot;Error closing files&quot;);<br>
  else<br>
  printf(&quot;%d file(s) closed&quot;,fcl);<br>
  &#8230;&#8230;&#8230;<br>
  }<br>
  READING AND WRITING STREAMS<br>
  fgetc()<br>
  prototype : int fgetc(FILE *stream);<br>
  The fgetc() returns the next character from the input stream from the current 
  position and increments the file position indicator. The character is read as 
  an unsigned char that is converted to an integer. if the end-of-file is reached, 
  fgetc() returns EOF.<br>
  e.g.:-<br>
  # include &lt;stdio.h&gt;<br>
  main()<br>
  {<br>
  char filename[13];<br>
  char ch;<br>
  FILE *fp;<br>
  printf(&quot;Enter Filename : &quot;);<br>
  gets(filename);<br>
  if((fp=fopen(filename,&quot;r&quot;))==NULL)<br>
  {<br>
  printf(&quot;Cannot open %s&quot;,filename);<br>
  exit(1);<br>
  }<br>
  while((ch=fgetc(fp))!=EOF)<br>
  {<br>
  putchar(ch);<br>
  }<br>
  fclose(fp);<br>
  }<br>
  Since EOF is a valid integer value, you must use feof() to check for end-of-file 
  when working with binary file.<br>
  feof()<br>
  prototype : int feof(FILE *stream);<br>
  The feof() checks the file position indicator to determine if the end of file 
  associated with stream has been reached. A non-zero (true) value is returned 
  if the file position indicator is at the end of file. Otherwise, the function 
  returns zero (false).<br>
  eg:-<br>
  while(!feof(fp))<br>
  {<br>
  putchar(fgetc(fp));<br>
  }<br>
  fputc()<br>
  prototype : int fputc(int ch, FILE *stream);<br>
  The fputc() writes a character to a specified stream at the current file position 
  and then advances the file position indicator . If successful, fputc() returns 
  the value of the character written, otherwise EOF is returned. <br>
  e.g.:-<br>
  # include &lt;stdio.h&gt;<br>
  main()<br>
  {<br>
  char filename[13],ch;<br>
  FILE *fp;<br>
  printf(&quot;Enter filename : &quot;);<br>
  gets(filename);<br>
  if((fp=fopen(filename, &quot;w&quot;))==NULL)<br>
  {<br>
  printf(&quot;Cannot open %s&quot;,filename);<br>
  exit(1);<br>
  }<br>
  while((ch=getch())!='X' )<br>
  {<br>
  fputc(ch, fp);<br>
  }<br>
  fclose(fp);<br>
  }</p>
<p>getc()<br>
  prototype : int getc(FILE *stream);<br>
  same as fgetc();<br>
  putc()<br>
  prototype : int putc(int ch, FILE *stream);<br>
  same as fputc();<br>
  fgets()<br>
  prototype : char *fgets(char *string, int length, FILE *stream);<br>
  fgets() reads a string from the specified stream until either a newline(\n) 
  character is read or length-1 characters have been read. If a newline is read, 
  it would be a part of the string, unlike gets(). The resultant string would 
  be NULL terminated. The function returns a pointer to string if successful and 
  a NULL pointer if an error occurs.<br>
  fputs()<br>
  prototype : int fputs(char *string, FILE *stream);<br>
  fputs() writes the string to the specified file stream starting at the current 
  location, unless the stream is opened in append mode in which case it is written 
  at EOF.<br>
  Sample program to simulate DOS COPY command<br>
  # include &lt;stdio.h&gt;<br>
  main()<br>
  {<br>
  FILE *in, *out;<br>
  char str[81], file1[13], file2[13];<br>
  printf(&quot;Enter source file name : &quot;);<br>
  gets(file1);<br>
  printf(&quot;Enter target file name : &quot;);<br>
  gets(file2);<br>
  if((in=fopen(file1, &quot;r&quot;))==NULL)<br>
  {<br>
  printf(&quot;%s not found&quot;); exit(1);<br>
  }<br>
  if((out=fopen(file2, &quot;w&quot;))==NULL)<br>
  {<br>
  printf(&quot;Cannot create %s &quot;, file2);<br>
  exit(1);<br>
  }<br>
  while(!feof(in))<br>
  {<br>
  if(fgets(str, 81, in))<br>
  {<br>
  fputs(str, out);<br>
  }<br>
  } <br>
  fcloseall();<br>
  }<br>
  FLUSHING STREAMS<br>
  The fclose() and fcloseall() flush the streams before closing the files. But 
  if you want to flush the contents of streams without closing them, use the fflush() 
  and flushall() functions.<br>
  The action of flushing depends upon the file type. A file opened for read will 
  have its input buffer cleared, while a file opened for write will have its output 
  buffer written to the file.<br>
  fflush()<br>
  prototype : int fflush(FILE *stream);<br>
  Flush the buffer leaving the file stream open. returns 0 on success and EOF 
  on failure.<br>
  flushall()<br>
  prototype : int flushall(void);<br>
  flush all buffers leaving files open. Returns the number of files flushed.</p>
<p>STANDARD STREAMS<br>
  Whenever a 'C' program starts execution under DOS five special file streams 
  are opened automatically by the operating system. They are the standard input 
  (stdin), the standard output(stdout), standard error(stderr), standard printer(stdprn) 
  and the standard auxiliary(stdaux). The stdin is assigned to the keyboard, stdout 
  and stderr are assigned to the monitor, stdprn is assigned to the first parallel 
  printer port and stdaux is assigned to the first serial port. They are defined 
  as fixed pointers of type FILE.<br>
  Sample program to print the contents of a file to printer<br>
  # include &lt;stdio.h&gt;<br>
  main()<br>
  {<br>
  FILE *in;<br>
  char buffer[81],filename[13];<br>
  printf(&quot;Enter file name to print : &quot;);<br>
  gets(filename);<br>
  if((in=fopen(filename, &quot;r&quot;))==NULL)<br>
  { <br>
  fputs(&quot;File not found&quot;, stderr);<br>
  exit(1);<br>
  }<br>
  while(!feof(in))<br>
  {<br>
  if(fgets(buffer, 81, in))<br>
  {<br>
  fputs(buffer, stdprn);<br>
  }<br>
  } fclose(in);<br>
  }<br>
  CURRENT ACTIVE POINTER<br>
  In order to keep track of the position where I/O operations are to take place, 
  a pointer is maintained in the FILE structure. Whenever a character is read 
  from or written to the stream the current active pointer is advanced. Most of 
  the I/O functions refer to current active pointer and update it after the input 
  or output procedures on the stream.<br>
  ftell()<br>
  prototype : long int ftell(FILE *fp);<br>
  The ftell() returns a long int value which gives the position of current active 
  pointer in the specified stream.<br>
  e.g.:- printf(&quot;Current position = %ld&quot;, ftell(fp));<br>
  SETTING CURRENT POSITION<br>
  Immediately after opening the stream the current active pointer position is 
  set to zero and points to the first byte of the stream. Whenever a character 
  is read from or written to the stream, the current active pointer is automatically 
  advanced, the pointer may be set to any position other than the current pointer, 
  at any time in the program.<br>
  rewind()<br>
  prototype : void rewind(FILE *fp);<br>
  Rewind() takes the current active pointer back to the beginning of the stream 
  from any point on the stream. This function allows to restart the file without 
  closing the file and reopening it.<br>
  fseek()<br>
  prototype : int fseek(FILE *fp, long int offset, int origin);<br>
  fseek() repositions the current active pointer by a specified number of bytes 
  from either the start, the current position or the end of the stream, depending 
  upon the position specified to the fseek(). The offset is the number of bytes 
  beyond the file location given by origin. Origin must be one of the values 0,1 
  or 2 which represent three symbolic constants defined in stdio.h as follows<br>
  SEEK_SET or 0 - Beginning of file<br>
  SEEK_CUR or 1 - Current file pointer position<br>
  SEEK_END or 2 - End-of-file<br>
  A return value of zero means fseek() succeeded and non-zero value means failure.<br>
  e.g.:- fseek(fp, 0L, SEEK_SET);<br>
  The above example takes the pointer to the beginning of the stream which is 
  equiva-lent to rewind(fp);<br>
  The offset may be positive, meaning move forwards or negative meaning move backwards.<br>
  e.g.:-<br>
  fseek(fp, 0L, 0); - go to beginning(rewind)<br>
  fseek(fp, 0L, 1); - stay at the current position<br>
  fseek(fp, 0L, 2); - go to the end-of-file, past the last character of the file<br>
  fseek(fp, 10L, 0); - move to 11th byte in the file<br>
  fseek(fp, 10L, 1); - move forward by 10 bytes<br>
  fseek(fp, -m, 1); - go backward by m bytes from the current position<br>
  fseek(fp, -m, 2); - go backward by m bytes from the end<br>
  When the operation is successful, fseek() returns a zero. If the program attempts 
  to move the file pointer beyond the file boundaries an error occurs and fseek 
  returns -1(non-zero).<br>
  fprintf() and fscanf()<br>
  The functions fprintf and fscanf perform I/O operations that identical to the 
  familiar printf and scanf functions, except that they work on files.<br>
  syntax : fprintf(FILE *stream, &quot;control string&quot;, arguments);<br>
  fprintf sends output to the specified file stream. fprintf returns the number 
  of bytes output. In case of error, it returns EOF.<br>
  syntax : fscantf(FILE *stream, &quot;control string&quot;, arguments);<br>
  fscanf performs a formatted input from the specified stream. Returns the number 
  of input fields successfully scanned, converted and stored, the returned value 
  does not include unstored scanned fields.<br>
  e.g.:- fscanf(fp, &quot;%s %d&quot;, name, &amp;age);<br>
  fprintf(stdout,&quot; %s -- %d&quot;, name, age);<br>
  BLOCK I/O<br>
  The block I/O functions are used to read or write continuous blocks of bytes 
  from and to a file. Each block will generally represent a complex data structure, 
  such as a structure or an array. For example, it is easier to read or write 
  an entire block of data rather than reading or writing the individual components 
  (i.e., structure members) within a block separately.<br>
  prototypes : size_t fread(void *buffer, size_t num_bytes, size_t count, FILE 
  *stream);<br>
  size_t fwrite(void *buffer, size_t num_bytes, size_t count, FILE *stream);<br>
  The data type size_t is an ANSI 'C' addition to improve portability. It is predefined 
  as an integer type large enough to hold sizeof() results. Usually it is equivalent 
  to unsigned integer. For fread() buffer is a pointer to the region of memory 
  that will receive the data item from the file. For fwrite(), buffer is a pointer 
  to the information that will be written to the file.<br>
  The number of bytes to read or written is specified by num-bytes. The argument 
  count determines how many items(each num-bytes in length) are read or written.<br>
  The fread() returns the number of items read. This value be less than count 
  if the end-of-file is reached or an error occurs. The fwrite() returns the number 
  of items written. This value will equal to count unless an error occurs.<br>
  As long as the file has been opened for binary operations, fread() and fwrite() 
  can read and write any type of information.<br>
  e.g.:-<br>
  fread(&amp;buffer, sizeof(buffer), 1, fp);<br>
  fwrite(&amp;buffer, sizeof(buffer), 1, fp);<br>
  ARRAY OF POINTERS<br>
  The way there can be an array of ints or an array of floats, similarly there 
  can be an array of pointers. Since a pointer variable always contains an address, 
  an array of pointers would be nothing but a collection of addresses. The addresses 
  present in the array of pointers can be addresses of different variables or 
  addresses of arrays and array elements.<br>
  syntax : data_type *array_name[size of array];<br>
  eg:- int *arr[4]; an array of 4 integer pointers<br>
  float *price[10]; an array of 10 float pointers<br>
  Sample Programs: To show array of pointers can contain the addresses of different 
  data items.<br>
  i)<br>
  main()<br>
  {<br>
  int *arr[4];<br>
  int a=10, b=20, c=30,d=40,x=0;<br>
  arr[0]=&amp;a; arr[1]=&amp;b; arr[2]=&amp;c; arr[3]=&amp;d;<br>
  for(x=0;x&lt;4;x++)<br>
  {<br>
  printf(&quot;%u -- %d\n&quot;, arr[x], *(arr[x]) );<br>
  }<br>
  getch();<br>
  }<br>
  will print, The for loop in the program picks up the addresses present in <br>
  6784 - - 10 the elements of arr and prints the addresses present at there 6786 
  - - 20 and the values present at these addresses.<br>
  6788 - - 30 ( the addresses shown in the sample output are imagi-nary )<br>
  6790 - - 40<br>
  ii) <br>
  main() will print, 6202 - - 5101 - - 0, where <br>
  { 6202 is the base address of the pointer<br>
  int arr[]={0,1,2,3,4}, *p[5]; array, p, 5101 is the base address<br>
  p[0]=a; p[1]=a+1; p[2]=a+2; p[3]=a+3; p[4]=a+4; of integer array, a stored in 
  the first<br>
  printf(&quot;%u -- %u --%d&quot;,p,*p,*(*p) ); element of p, and 0 is the value 
  stored<br>
  } in the first element of array a.</p>
<p>iii)<br>
  main() will print,<br>
  { 6202 - - 5101 - - 0<br>
  int arr[]={0,1,2,3,4}, *p[5]; 6204 - - 5103 - - 1<br>
  p[0]=a; p[1]=a+1; p[2]=a+2; p[3]=a+3; p[4]=a+4; 6206 - - 5105 - - 2<br>
  for(i=0;i&lt;5;i++) 6207 - - 5107 - - 3<br>
  printf(&quot;%u -- %u --%d&quot;,&amp;p[i],p[i],*(p[i]) ); 6210 - - 5109 - - 
  4<br>
  } <br>
  iv)<br>
  main() will print,<br>
  { 6202 - - 5101 - - 0<br>
  int arr[]={0,1,2,3,4}, *p[5]; 6204 - - 5103 - - 1<br>
  p[0]=a; p[1]=a+1; p[2]=a+2; p[3]=a+3; p[4]=a+4; 6206 - - 5105 - - 2<br>
  for(i=0;i&lt;5;i++) 6207 - - 5107 - - 3<br>
  printf(&quot;%u -- %u --%d&quot;, p+i,*(p+i),*(*(p+i)) ); 6210 - - 5109 - - 
  4 <br>
  } <br>
  v) <br>
  main() <br>
  { <br>
  int arr[]={0,1,2,3,4}, *p[5],**ptr; will print, <br>
  p[0]=a; p[1]=a+1; p[2]=a+2; p[3]=a+3; p[4]=a+4; 5101 - - 0<br>
  ptr=p; 6202 - - 5101 - - 0<br>
  printf(&quot;%u - - %d \n&quot;, a, *a); 6202 - - 5101 - - 0<br>
  printf(&quot;%u - - %u - - %d \n&quot;, p, *p, **p); <br>
  printf(&quot;%u - - %u - - %d \n&quot;, ptr, *ptr, **ptr); <br>
  }<br>
  vi)<br>
  main()<br>
  {<br>
  int a[3][3]={ 1,2,3,4,5,6,7,8,9 }, *ptr[3]; will print,<br>
  ptr[0]=a[0]; ptr[1]=a[1]; ptr[2]=a[2]; 1 - - 4 - - 7<br>
  for(i=0;i&lt;3;i++) 1 - - 4 - - 7<br>
  printf(&quot;%d \t&quot;, *ptr[i] ); <br>
  printf(&quot;\n&quot;);<br>
  for(i=0;i&lt;3;i++) <br>
  printf(&quot;%d \t&quot;, *a[i] ); <br>
  }<br>
  Array of pointers mainly used for storing several strings in memory.<br>
  e.g.:- char *name[]={ &quot;joy&quot;, &quot;srinivas&quot;, &quot;jayaprakash&quot;, 
  &quot;antony&quot;, &quot;hussain&quot;, &quot;abijith&quot;};<br>
  In the above example names[] is an array of 6 pointers. It contains addresses 
  of given names. i.e., base address of &quot;joy&quot; is stored in names[0], 
  base address of &quot;antony&quot; is stored in names[3] and so on.<br>
  If we used a two-dimensional array to store these names, where each row will 
  be of equal lengths, it will take roughly 72 bytes in memory.<br>
  But by using the memory of pointers is strings will take only 41 bytes. Thus 
  one reason to store to make more efficient use of available memory.<br>
  Another advantage is that easy manipulation of strings. e.g.:- exchange of positions 
  of strings like in sorting of string arrays.<br>
  e.g.1:- string exchanging:<br>
  main()<br>
  {<br>
  char *names[]={&quot;joy&quot;, &quot;srinivas&quot;, &quot;jayaprakash&quot;, 
  &quot;antony&quot;, &quot;hussain&quot;, &quot;abijith&quot;};<br>
  char *temp;<br>
  printf(&quot;Before exchanging : &quot;);<br>
  printf(&quot;%s - - %s&quot;, names[2], names[3] );<br>
  temp = names[2];<br>
  names[2] = names[3];<br>
  names[3] = temp;<br>
  printf(&quot;\n After exchanging : &quot;);<br>
  printf(&quot;%s - - %s&quot;, names[2], names[3] );<br>
  getch();<br>
  }<br>
  will print,<br>
  Before exchanging : jayaprakash - - antony<br>
  After exchanging : antony - - jayaprakash<br>
  e.g. 2: sorting strings<br>
  main()<br>
  {<br>
  char *names[]={&quot;joy&quot;, &quot;srinivas&quot;, &quot;jayaprakash&quot;, 
  &quot;antony&quot;, &quot;hussain&quot;, &quot;abijith&quot;};<br>
  sort(names);<br>
  for(i=0; i&lt;6; i++)<br>
  printf(&quot;%s \n&quot;, arr[i] );<br>
  getch();<br>
  }<br>
  sort( char *names[])<br>
  {<br>
  int i, j;<br>
  char *temp;<br>
  for(i=0; i&lt;5; i++)<br>
  {<br>
  for(j=5; j&gt;i; j--)<br>
  {<br>
  if(strcmp(names[j], names[j-1]) &lt; 0)<br>
  {<br>
  temp=names[j];<br>
  names[j]=names[j-1];<br>
  names[j-1]=temp;<br>
  }<br>
  }<br>
  }<br>
  }<br>
  e.g.3 :- sorting strings <br>
  main()<br>
  {<br>
  char *names[]={&quot;joy&quot;, &quot;srinivas&quot;, &quot;jayaprakash&quot;, 
  &quot;antony&quot;, &quot;hussain&quot;, &quot;abijith&quot;};<br>
  sort(names);<br>
  for(i=0; i&lt;6; i++)<br>
  printf(&quot;%s \n&quot;, arr[i] );<br>
  getch();<br>
  }<br>
  sort( char *names[])<br>
  {<br>
  int i,j;<br>
  char *temp;<br>
  for(i=0; i&lt;5; i++)<br>
  {<br>
  for(j=5; j&gt;i; j--)<br>
  {<br>
  if(strcmp(names[j], names[j-1]) &lt; 0)<br>
  {<br>
  swap(&amp;names[j], &amp;names[j-1] );<br>
  }<br>
  }<br>
  }<br>
  }<br>
  swap(char *s1, char *s2)<br>
  {<br>
  char *temp;<br>
  temp = *s1;<br>
  *s1= *s2;<br>
  *s2= temp;<br>
  }<br>
  LIMITATION OF ARRAY OF POINTERS TO STRING<br>
  When we are using a two dimension array of characters we can either initialise 
  the strings where we are declaring the array or receive(accept) the string using 
  scanf(). However, when we are using an array of pointers to strings we can initialise 
  the strings at the place where we are declaring the array, we cannot accept 
  the strings from keyboard using scanf().<br>
  i.e., code like,<br>
  &#8230;&#8230;&#8230;&#8230;..<br>
  &#8230;&#8230;&#8230;&#8230;..<br>
  char *names[3];<br>
  printf(&quot;Enter a name : &quot;);<br>
  scanf(&quot;%s&quot;, name[i] );<br>
  &#8230;&#8230;&#8230;&#8230;<br>
  &#8230;&#8230;&#8230;&#8230;<br>
  Doesn't work because when we are declaring the array it is containing garbage 
  values, and it is wrong to send these garbage values to scanf() as the addresses 
  where it should keep the strings received from the keyboard.<br>
  Write a function month_name(int n);, which returns a pointer to a character 
  string containing the name of the nth month.<br>
  char *month_name(int n)<br>
  {<br>
  static char *name[]={ &quot;Illegal Month Number&quot;, &quot;January&quot;, 
  &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;,\<br>
  &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, 
  &quot;October&quot;, &quot;November&quot;, &quot;December&quot;<br>
  };<br>
  return( (n&lt;1 || n&gt;12) ? name[0] : name[n]) ;<br>
  }<br>
  COMMAND LINE ARGUMENTS<br>
  Command line arguments are the information made available to the program by 
  writing it after the program name on the command line of the operating system. 
  The command line arguments are used to pass information into the main() when 
  program begins executing.<br>
  main() can take two arguments usually called argc and argv and the information 
  contained in the command line is passed on to the main() through these arguments, 
  when main() is called up by the system.<br>
  The variable argc is an argument counter, which holds the number of arguments 
  including the program name on the command line, and is an integer. The argv 
  is an argument vector and represents an array of character pointers that point 
  to the command line arguments. Any type of argument in the command line is treated 
  as a string. The size of this array will be equal to the value of argc. You 
  can access the individual arguments by indexing (subscripting) argv.<br>
  The first parameter in the command line is always the program name and therfore 
  argv[0] always represents the program name, argv[1] points to the first argument 
  and so on. The argcth element points to NULL.<br>
  syntax : main( int argc, char *argv[])<br>
  {<br>
  .......<br>
  ......<br>
  }<br>
  for example, if we want to execute a program to copy the contents of a file 
  named file1 to another file named file2, then the command line like,<br>
  C:\&gt;DUP file1 file2<br>
  Where DUP is the executable program file name. Here argc is 3 and argv is as 
  shown below,<br>
  Q). Write a program to simulate the ECHO command available under DOS<br>
  # include &lt;stdio.h&gt;<br>
  main(int argc, char *argv[])<br>
  {<br>
  int i;<br>
  for(i=1; i&lt;argc;i++)<br>
  {<br>
  printf(&quot;%s\t&quot;,argv[i] );<br>
  }<br>
  }<br>
  OR<br>
  # include &lt;stdio.h&gt;<br>
  main(int argc, char *argv[])<br>
  {<br>
  int i=1;<br>
  while(argv[i]!=NULL)<br>
  {<br>
  printf(&quot;%s\t&quot;,argv[i++] );<br>
  }<br>
  }<br>
  OR<br>
  # include &lt;stdio.h&gt;<br>
  main(int argc, char *argv[])<br>
  {<br>
  int i=1;<br>
  while(i&lt;argc)<br>
  {<br>
  printf(&quot;%s\t&quot;,*argv );<br>
  argv++;<br>
  }<br>
  }<br>
  if any numeric value contained in the command line arguments will also passed 
  to the main() as a string. Therefore you must convert it to numeric before processing 
  using library functions like atoi(), atol(), atof() etc.<br>
  Q. Write a program to print the specified no. of dots(.) .<br>
  /* dots.c */<br>
  # include &lt;stdio.h&gt;<br>
  void main(int argc, char *argv[])<br>
  {<br>
  int i;<br>
  if(argc &lt; 2)<br>
  {<br>
  printf(&quot;You must specify a number&quot;);<br>
  printf(&quot; with the program name \n&quot;);<br>
  printf(&quot;Try again&quot;);<br>
  exit(1);<br>
  }<br>
  for(i=1; i&lt;=atoi(argv[1]); i++)<br>
  putchar('.');</p>
<p> printf(&quot;%s completed&quot;, argv[0]);<br>
  putchar(7); /* to create a beep sound */<br>
  }<br>
  An example program execution, C:\&gt; dots 20 <br>
  ? A program with command line arguments should issue instructions, if the user 
  attempts to run the program without proper information. The command line argu-ments 
  give the program a professional appearance. It is not necessary that you should 
  always use the variable names argc and argv. In place of them any other valid 
  variable name can be used.<br>
  Q1. Write a program tail, which prints the last 'n' lines of the specified file. 
  By default, n is 10. But it can be changed by an optional command line argument. 
  ie., tail file1 should print the last 10 lines of file1, and tail file2 15 should 
  print the last 15 lines of file2.<br>
  Q2. Write a program head, which prints the first n lines of the specified.(use 
  com-mand line arguments)<br>
  Q3. Write a program to simulate the DOS external command FILD which prints the 
  lines of the given file that contains the given word. There are options that 
  changes the default meaning.<br>
  n - line numbers before each line<br>
  c - only total no. of lines<br>
  i - ignore case difference<br>
  x - will print each line that doesn&#8217;t match the given word<br>
  FUNCTIONS RETURNING POINTERS<br>
  The way functions return an int, a float, a double or any other data type, it 
  can also return a ointer(address). To make a function return a pointer it has 
  to be mentioned in the calling function as well as in the function declaration 
  (prototype).<br>
  Syntax: datatype *function-name (arguments);<br>
  eg: (1)<br>
  # include &lt;stdio.h&gt;<br>
  main()<br>
  {<br>
  int *p;<br>
  int *function();<br>
  p=function;<br>
  printf(&quot;%u -- %d&quot;,p,*p);<br>
  }<br>
  s<br>
  int *function()<br>
  {<br>
  int i=20;<br>
  return(&amp;i);<br>
  }<br>
  eg: (2)<br>
  # include &lt;stdio.h&gt;<br>
  float *function(float *r);<br>
  main()<br>
  {<br>
  float p=45.67, q=28.94, *x;<br>
  c=&amp;p;<br>
  printf(&quot;Before calling *x = %f\n&quot;,*x);<br>
  x=function(&amp;p);<br>
  printf(&quot;After calling *x = %f\n&quot;,*x);<br>
  getch();<br>
  }<br>
  float *function(float *r)<br>
  {<br>
  r=r+1;<br>
  return(r);<br>
  }<br>
  eg: (3)<br>
  # include &lt;stdio.h&gt;<br>
  char *addstring(char *s1, char *s2);<br>
  main()<br>
  {<br>
  char s1[30],s2[10], *ptr;<br>
  printf(&quot;Enter first string : &quot;); gets(s1);<br>
  printf(&quot;Enter second string : &quot;); gets(s2);<br>
  ptr=addstring(s1,s2);<br>
  printf(&quot;\nAfter addition S1 = %s&quot;,ptr);<br>
  getch();<br>
  }<br>
  char *addstring(char *s1, char *s2)<br>
  {<br>
  int i,j;<br>
  for(i=0; s1[i]!=NULL; i++); ?Version 1<br>
  for(j=0; s2[j]!=NULL; s1[i]=s2[j],i++,j++);<br>
  return s1;<br>
  }<br>
  char *addstring(char *s1, char *s2)<br>
  {<br>
  int i,j;<br>
  for(i=0; s1[i]!=NULL; i++); ?Version 2<br>
  for(j=0; (s1[i]=s2[j])!=NULL;i++,j++);<br>
  return s1;<br>
  }<br>
  char *addstring(char *s1, char *s2)<br>
  {<br>
  char *ptr=s1;<br>
  for(;*s1!=NULL;s1++);s1--; ?Version 3<br>
  for(;(*s1=*s2)!=NULL;s1++,s2++);<br>
  return ptr;<br>
  }<br>
  char *addstring(char *s1, char *s2)<br>
  {<br>
  char *ptr=s1;<br>
  for(;*s1++!=NULL;);s1--; ?Version 4<br>
  for(;(*s1++=*s2++)!=NULL;);<br>
  return ptr;<br>
  }<br>
  char *addstring(char *s1, char *s2)<br>
  {<br>
  char *ptr=s1;<br>
  for(;*s1++;); s1--; ?Version 5<br>
  for(;*s1++ = *s2++;);<br>
  return ptr;<br>
  }<br>
  POINTERS TO FUNCTIONS<br>
  Even though a function is not a variable it has a physical location in memory 
  that can be assigned to a pointer. A function&#8217;s address is the entry point 
  of the function. Because of this, a function pointer can be used to call a function.<br>
  In &#8216;C&#8217;, as each function is compiled, source code is transformed 
  into object code and an entry point is established. When a call is made to a 
  function while your program is running, a machine language call is made to this 
  point. Therefore, if a pointer con-tains the address of a function&#8217;s entry 
  point, it can be used to call that function.<br>
  To obtain the address of a function, use the function&#8217;s name without any 
  parenthe-ses and arguments.<br>
  syntax: datatype (*ptr)();<br>
  The above declaration tells that ptr is a pointer to a function which returns 
  the speci-fied datatype.<br>
  eg: int (*ptr)();<br>
  ptr = strcmp;<br>
  To invoke the function using function pointer use the syntax, (*ptr)();<br>
  eg: to invoke the strcmp function,<br>
  (*ptr)(string1,string2);<br>
  Sample Program (1) To show functions also have address<br>
  # include &lt;stdio.h&gt;<br>
  main()<br>
  {<br>
  int show();<br>
  printf(&#8220;Address of function show = %u &#8220;,show);<br>
  show();<br>
  }<br>
  show()<br>
  {<br>
  printf(&#8220;This is a sample program&#8221;);<br>
  }<br>
  Sample Program (2) Using pointer to function<br>
  # include &lt;stdio.h&gt;<br>
  int show();<br>
  main()<br>
  {<br>
  int (*ptr)();<br>
  ptr=show;<br>
  printf(&#8220;Address of function show = %u &#8220;,ptr);<br>
  (*ptr)(); /* to invoke the function show using the pointer to function */<br>
  }<br>
  show()<br>
  {<br>
  printf(&#8220;This is the second sample program&#8221;);<br>
  }<br>
  Sample Program (3) Comparing two strings for equality<br>
  # include &lt;stdio.h&gt;<br>
  # include &lt;string.h&gt;<br>
  void check( char *a, char *b, int (*cmp)() );<br>
  main()<br>
  {<br>
  char s1[80],s2[80];<br>
  int (*ptr)();<br>
  ptr=strcmp;<br>
  printf(&#8220;Enter first string : &#8220;); gets(s1);<br>
  printf(&#8220;Enter second string : &#8220;); gets(s2);<br>
  check(s1,s2,ptr);<br>
  }<br>
  void check(char *a, char *b, int (*cmp)() )<br>
  {<br>
  if( !(*cmp)(a,b) )<br>
  printf(&#8220;Equal&#8221;);<br>
  else<br>
  printf(&#8220;Not equal&#8221;);<br>
  }<br>
  UNIONS<br>
  A union is a memory location that is shared by two or more different variables, 
  generally of different types, at different times. Defining a union is similar 
  to defining a structure, using the keyword union.<br>
  syntax :<br>
  union tag<br>
  {<br>
  type member-1;<br>
  type member-2;<br>
  &#8230;&#8230;&#8230;&#8230;..<br>
  &#8230;&#8230;&#8230;&#8230;..<br>
  type member-n;<br>
  };<br>
  The major difference between structures and unions is in terms storage. In structures 
  each member has its own storage location, whereas all the members of a union 
  use the same location.<br>
  e.g.:- union data<br>
  {<br>
  int x;<br>
  float y;<br>
  char ch;<br>
  };<br>
  This definition does not declare any variables. You may declare a variable either 
  by placing the variable&#8217;s name at the end of the definition or by using 
  a separate decla-ration statement.<br>
  e.g.:- union data item1;<br>
  Although a union may contain many members of different types, it can handle 
  only one member at a time. When a union is declared, the compiler automatically 
  creates (allocates) a variable large enough to hold the largest type in the 
  union.<br>
  To access the union element, use the dot (.) or arrow (?) operators as for structures. 
  If you are operating on the union variable directly, use the dot operator. If 
  the union variable is accessed through a pointer, use the arrow operator.<br>
  e.g.: (1) item1.y = 56.457;<br>
  e.g.: (2) function(union data *ptr)<br>
  {<br>
  ptr-&gt;x =10&#8217;<br>
  printf(&#8220;Ptr?x = %d&#8221;, ptr?x);<br>
  }<br>
  The program can use only one member at a time because only one location is allocated 
  for a union variable. During accessing, the program can access only the member 
  whose value is currently stored. When a different member is assigned a new value, 
  the new value supersedes the previous member&#8217;s value.<br>
  SYMBOLIC CONSTANTS / MACROS<br>
  Macro substitution is a process where an identifier in a program is replaced 
  by a predefined string. Macro substitution is accomplished by using #define 
  pre-processor statement.<br>
  syntax : # define identifier string(value)<br>
  e.g.: #define MAX 100<br>
  All #define directives must be placed before the function main (). It is customary 
  but not mandatory to use all uppercase letter for macro names used in #define 
  state-ment, only to give a visual idea that they are not ordinary variables. 
  No semicolons is used after the last argument, since #define is a directive 
  and not a &#8216;C&#8217; statement. The #define statement can be used for character 
  (enclosed within single quotes) and string constants (enclosed within double 
  quotes). #define can be also used for defining aliases for &#8216;C&#8217; keywords. 
  One #define directive can be used to define only one symbolic constant/macro. 
  So if you want to define more than one symbolic constant/macro use multiple 
  #define statements and place them before main (). When the program is compiled 
  the symbolic constant/macro is replaced by its value. This is called compile-time 
  substitution. Symbolic constants enclosed in double quotes are not substituted. 
  In a #define directive statement for a string constant, if the string is too 
  long to fit in a single line, it can be continued on the next line by typing 
  an escape character (\) at the end of first line. A #define statement can not 
  contain a newline character.<br>
  e.g.: (1)</p>
<p> <br>
  # include &lt;stdio.h&gt;</p>
<p> #include&lt;getch.h&gt;<br>
  #define FALSE 0<br>
  # define PI 3.1415926<br>
  # define CAPITAL &#8220;DELHI&#8221;<br>
  main()<br>
  {<br>
  printf(&#8220;%d&#8221;, FALSE);<br>
  printf(&#8220;%f&#8221;, PI);<br>
  printf(&#8220;CAPITAL = %s&#8221;, CAPITAL);<br>
  }<br>
  e.g.: (2)<br>
  #define EQUALS ==<br>
  #define AND &amp;&amp;<br>
  #define OR ||<br>
  #define NOT_EQUAL !=<br>
  #define START main(){<br>
  #define END }<br>
  #define MOD %<br>
  #define INCREMENT ++</p>
<p>START<br>
  &#8230;&#8230;&#8230;&#8230;.<br>
  If(total EQUALS 100 AND eng NOT_EQUAL 25)<br>
  INCREMENT count;<br>
  &#8230;&#8230;&#8230;&#8230;.<br>
  &#8230;&#8230;&#8230;..<br>
  END<br>
  MACROS WITH ARGUMENTS<br>
  syntax : # define identifier(arguments) string<br>
  The arguments are formal arguments like in the formal arguments of in a function 
  header.<br>
  e.g.:- # define CUBE(x) ((x)*(x)*(x))<br>
  The above macro can be called as CUBE(5),<br>
  printf(&quot;%d&quot;, CUBE(5) );<br>
  e.g.s:-<br>
  # define MAX(a,b) (((a) &gt; (b)) ? (a) : (b))<br>
  # define MIN(a,b) (((a) &lt; (b)) ? (a) : (b))<br>
  # define ABS(x) (((x) &gt; 0) ? (x) : (-(x)))<br>
  # define ISUPPER (ch) ((ch)&gt;='A' &amp;&amp; (ch)&lt;='Z') ? 1 : 0<br>
  NESING OF MACROS<br>
  # define M 5<br>
  # define N M+1<br>
  # define SQ ((x)*(x))<br>
  # define CUBE(x) (SQ(x) * (x))<br>
  ENUMERATIONS<br>
  syntax : enum { &lt;identifier1&gt; [ = &lt;const&gt; ] , &lt;identifier2&gt; 
  [ = &lt;const&gt; ], .... } ;<br>
  Defines a set of constants of type int. &lt;identifier1&gt; is the name of a 
  constant that can optionally be assigned the value of &lt;const&gt;. If &lt;const&gt; 
  is missing, then a value is assumed to be the value of the previous constant 
  in the list + 1. If this is the first constant in the list, the default value 
  is 0.<br>
  e.g. : <br>
  enum {LASTMODE=-1, BW40=0, C40, BW80, C80, MONO=7};<br>
  enum {ZERO, ONE, TWO, THREE, FOUR, FIVE};<br>
  Sample Program :<br>
  # include &lt;stdio.h&gt;<br>
  main()<br>
  {<br>
  int ch;<br>
  enum {ADD=1, MODIFY, DELETE, LIST, EXIT};<br>
  while(1)<br>
  {<br>
  clrscr();<br>
  printf(&quot; 1. ADD RECORDS &quot;);<br>
  printf(&quot; 2. MODIFY RECORDS &quot;);<br>
  printf(&quot; 3. DELETE RECORDS &quot;);<br>
  printf(&quot; 4. LIST RECORDS&quot;);<br>
  printf(&quot; EXIT PROGRAM &quot;);<br>
  printf(&quot;Enter Your Choice : &quot;):<br>
  scanf(&quot;%d&quot;, &amp;ch);<br>
  switch(ch)<br>
  {<br>
  case ADD :<br>
  statements 1;<br>
  case MODIFY :<br>
  statements 2;<br>
  case DELETE :<br>
  statements 3;<br>
  case LIST :<br>
  statements 4;<br>
  case EXIT :<br>
  exit(1) ;<br>
  }<br>
  }<br>
  }<br>
  SCREEN HANDLING IN &#8216;C&#8217;</p>
<p><br>
  Video Adapters <br>
  The four most common adapters available on IBM PC-compatibles are the mono-chrome 
  Display Adapter(MDA), the Color Graphics Adapter(CGA), the Enhanced Grahics 
  Adapter(EGA) and the Visual Graphics Array(VGA).<br>
  The Monochrome Adapter can work only with text in 80x25 format. ie., it can 
  only display 25 lines of text, 80 columns per line. The CGA and others have 
  several modes of operation including 40 and 80 column text as well as graphics 
  operations.<br>
  Mode Type Dimensions Adapters<br>
  0 Text, B/W 40x25 CGA, EGA<br>
  1 Text, 16 colors 40x25 CGA, EGA<br>
  2 Text, B/W 80x25 CGA, EGA<br>
  3 Text, 16 colors 80x25 CGA, EGA<br>
  4 Graphics, 4 colors 320x200 CGA, EGA<br>
  5 Graphics, 4 gray tones 320x200 CGA, EGA<br>
  6 Graphics, B/W 640x200 CGA, EGA<br>
  7 Text, B/W 80x25 CGA, EGA<br>
  Display Colors</p>
<p><br>
  If you have a CGA/EGA/VGA adapter, the default display is in text mode with 
  black background and lightgray foreground. TURBO C provides facilities to change 
  the background and foreground colors with the following functions, where the 
  prototypes are in the conio.h header file.<br>
  The function textbackground() selects new text background color.<br>
  prototype : void textbackground(int newcolor);<br>
  The function textcolor() selects new foreground character color in the text 
  mode.<br>
  prototype : void textcolor(int newcolor);<br>
  The enumerations type COLORS defined in the header file conio.h of TURBO C can 
  be used for standard CGA/EGA/VGA video colors/attributes and have the following 
  values BLACK, BLUE, GREEN, CYAN, RED, MAGENTA, BROWN, LIGHTGRAY, DARKGRAY, LIGHTBLUE, 
  LIGHTGREEN, LIGHTCYAN, LIGHTRED, LIGHTMAGENTA, YELLOW, WHITE. You can use the 
  integers 0 through 15 to represent any of the above colors. Only the first seven 
  colors (0 through 6) are allowed for text background.<br>
  In order to display text on the screen using the new background and foreground 
  attributes, use the function cprintf() rather than the printf() function. This 
  is because the printf() ignores the current color settings.<br>
  Adding 128 or BLINK to the foreground color makes the displayed characters blink 
  in the text mode.<br>
  e.g.:<br>
  # include &lt;stdio.h&gt;<br>
  # include &lt;conio.h&gt;<br>
  main()<br>
  {<br>
  textbackground(BLUE);<br>
  textcolor(YELLOW+BLINK);<br>
  cprintf(&#8220;%s&#8221;,name);<br>
  getch();<br>
  }<br>
  The Video RAM<br>
  The characters displayed on the screen are held in the RAM in portion reserved 
  for Video Adapters. The base address of video memory for the Monochrome adapters 
  is B0000000H and for the CGA and EGA adapters the base is at B8000000H. Each 
  character displayed on the screen requires two bytes of video memory. The first 
  byte holds the actual character and the second holds its screen attribute. To 
  create lighting fast displays, programmer can access the video RAM.<br>
  Reading and writing the Video RAM requires the use of far pointers. For applications 
  to operate correctly for each adapter, they need to know which video adapter 
  is used in the system. The easiest way to do this is to use ROM-BIOS interrupt 
  16, function 15 which returns the current video mode. The following function 
  finds out which video mode is being used currently, and returns a pointer to 
  the video memory accordingly.<br>
  function viddetect to find out the current video mode:-<br>
  char far *viddetect()<br>
  {<br>
  _AH=15;<br>
  geninterrupt(16);<br>
  if( (_AL!=2) &amp;&amp; (_AL!=3) &amp;&amp; (_AL!=7) )<br>
  {<br>
  printf(&#8220;Video must be in 80 column text mode&#8221;);<br>
  exit(1);<br>
  }<br>
  if(_AL==7)<br>
  return (char far *) 0xB0000000;<br>
  else<br>
  return (char far *) 0xB8000000;<br>
  }<br>
  Cursor Positioning<br>
  In text mode, their row and column numbers references individual character loca-tions 
  on the screen. There are 25 rows from 0 to 24 and 80 columns from 0 to 79. The 
  upper left corner of the screen is location 0,0 in Video RAM and 1,1 on the 
  screen.<br>
  The same can be achieved by directly accessing the Video Ram using the following 
  formula:<br>
  scr_pos = vid_mem + (160 * l ) + (2 * c);<br>
  Where l and c are the line and column numbers respectively.<br>
  GRAPHICS IN &#8216;C&#8217;<br>
  Before you can use graphics functions you have to place the computer into appropri-ate 
  video mode. TURBO C provides two functions detectgraph() and initgraph() to 
  check the allowed mode and to initialise your computer to a required mode. They 
  are prototyped in GRAPHICS.H as<br>
  void far detectgraph(int *graphicsdriver, int *graphicsmode);<br>
  void far inittgraph(int *graphicsdriver, int *graphicsmode, char *pathtodriver);<br>
  The detectgraph() determines the presence of graphics hardware in the system 
  and choose the highest resolusion for the adapter. The initgraph() function 
  actually initializes the graphics system by loading a graphics driver from disk.<br>
  With detectgraph(), *graphicsdriver gets the value of the graphics driver. If 
  no graph-ics hardware is detected, *graphicsdriver is set to &#8211;2. *graphicsmode 
  specifies the graphics mode. With initgraph(), *graphicsdriver specifies the 
  graphics driver to be used and *grphicsmode specifies the graphics mode. *pathtodriver 
  specifies the directory path where initgraph() will look for the graphics driver.<br>
  Some graphics_drivers supported by Turbo C<br>
  CGA <br>
  EGA <br>
  EGAMONO <br>
  VGA <br>
  MCGA <br>
  DETECT (Requests auto-detection)<br>
  Some graphics_modes for each driver supported by Turbo C.<br>
  CGAC0 320x200 palette 0<br>
  CGAHI 640x200<br>
  MCGAC0 320x200 palette 0<br>
  MCGAMED 640x200<br>
  MCGAHI 640x480<br>
  EGALO 640x200 16 color<br>
  EGAHI 640x350 16 color<br>
  EGA64LO 640x200 16 color<br>
  EGA64HI 640x350 4 color<br>
  EGAMONOHI 640x350<br>
  VGALO 640x200<br>
  VGAMED 640x350<br>
  VGAHI 640x480<br>
  PIXELS<br>
  The most fundamental graphics routine is the one that writes the pixel, the 
  smallest addressable point on the video monitor. Turbo C allows you to write 
  a pixel at speci-fied point on your screen with the help of the putpixel().<br>
  prototype : void far putpixel(int x, int y, int color);<br>
  where x and y are the screen co-ordinates and color specifies the color with 
  which the pixel is drawn on the screen. e.g.:- putpixel(200, 100, 3);<br>
  some functions from graphics.h<br>
  bar: draws a bar<br>
  void far bar(int left, int top, int right, int bottom);<br>
  bar3d: draws a 3-D bar<br>
  void far bar3d(int left, int top, int right, int bottom, int depth, int topflag);<br>
  circle: draws a circle at (x,y) of the given radius<br>
  void far circle(int x, int y, int radius);<br>
  cleardevice: clears the graphics screen<br>
  void far cleardevice(void);<br>
  clearviewport: clears the current viewport<br>
  void far clearviewport(void);<br>
  ellipse: draws an elliptical arc<br>
  void far ellipse(int x, int y, int stangle, int endangle, int xradius, int yradius);<br>
  (x,y) is the center point. stangle and endangle are start and end angles in 
  de-grees. xradius and yradius are horizontal and vertical radii.<br>
  fillellipse: draws and fills elliptical arc<br>
  void far fillellipse(int x, int y, int xradius, int yradius);<br>
  Uses (x,y) as the center point and fills arc using the current fill pattern. 
  xra-dius and yradius are horizontal and vertical radii.<br>
  floodfill: flood-fills a bounded region<br>
  void far floodfill(int x, int y, int border);<br>
  getimage: saves a bit image of the specified<br>
  region into memory<br>
  void far getimage(int left, int top, int right, int bottom, void far *bitmap);<br>
  getmaxcolor: returns maximum color value<br>
  int far getmaxcolor(void);<br>
  getmaxx: returns maximum x screen coordinate<br>
  int far getmaxx(void);<br>
  getmaxy: returns maximum y screen coordinate<br>
  int far getmaxy(void);<br>
  line: draws a line between two specified points<br>
  void far line(int x1, int y1, int x2, int y2);<br>
  Draws a line from (x1,y1) to (x2,y2) using the current color, line style and 
  thickness.<br>
  lineto: draws a line from the Current Position to (x,y)<br>
  void far lineto(int x, int y);<br>
  moveto: moves the Current Position to (x,y)<br>
  void far moveto(int x, int y);<br>
  outtext: displays a string in the viewport <br>
  void far outtext(char far *textstring);<br>
  outtextxy: sends a string to the specified location (graphics mode)<br>
  void far outtextxy(int x, int y, char far *textstring);<br>
  pieslice: draws and fills in pie slice<br>
  void far pieslice(int x, int y, int stangle, int endangle, int radius);<br>
  putimage: outputs a bit image onto the screen<br>
  void far putimage(int left, int top, void far *bitmap, int op);<br>
  bitmap points to a bitmap, normally created by the getimage function. The op 
  value specifies how the image will be combined with the current contents of 
  the area at (left,top).<br>
  imagesize: returns the number of bytes required to store a bit image<br>
  unsigned far imagesize(int left, int top, int right, int bottom);<br>
  If the size required for the selected image is greater than or equal to 64K-1 
  bytes, it returns 0xFFFF.<br>
  rectangle: draws a rectangle (graphics mode)<br>
  void far rectangle(int left, int top, int right, int bottom);<br>
  Uses current line style, thickness and color.<br>
  sector: draws/fills elliptical pie slice<br>
  void far sector(int x, inty, int stangle, int endangle, int xradius, int yradius);<br>
  x and y define the center point. stangle and endangle define start and end an-gles. 
  xradius and yradius are horizontal and vertical radii.<br>
  setcolor: sets the current drawing color<br>
  void far setcolor(int color);<br>
  setfillstyle: sets the fill pattern and color<br>
  void far setfillstyle(int pattern, int color);<br>
  setfillstyle patterns<br>
  EMPTY_FILL uses background color<br>
  SOLID_FILL uses solid fill color<br>
  LINE_FILL --- fill<br>
  LTSLASH_FILL /// fill<br>
  SLASH_FILL /// fill thick lines<br>
  BKSLASH_FILL \\\ fill thick lines<br>
  LTBKSLASH_FILL \\\ fill<br>
  settextstyle: sets the current text characteristics<br>
  void far settextstyle(int font, int direction, int charsize);<br>
  Enumerated type: font_names<br>
  DEFAULT_FONT 8x8 bit mapped font<br>
  TRIPLEX_FONT &quot;Stroked&quot; fonts<br>
  SMALL_FONT0<br>
  SANS_SERIF_FONT<br>
  GOTHIC_FONT<br>
  Defines: direction of graphics output<br>
  HORIZ_DIR left to right<br>
  VERT_DIR bottom to top<br>
  System Date &amp; Time Functions<br>
  gettime: gets system time<br>
  syntax : void gettime(struct time *timeptr);<br>
  Structure: time<br>
  struct time<br>
  {<br>
  unsigned char ti_min;<br>
  unsigned char ti_hour;<br>
  unsigned char ti_hund;<br>
  unsigned char ti_sec;<br>
  };<br>
  getdate: gets MS-DOS date<br>
  syntax : void getdate(struct date *dateptr);<br>
  Structure: date<br>
  struct date<br>
  {<br>
  int da_year;<br>
  char da_day;<br>
  char da_mon;<br>
  };<br>
  Sample Program to print current system date and time:<br>
  # include &lt;stdio.h&gt;<br>
  # include &lt;dos.h&gt;<br>
  void main()<br>
  {<br>
  struct time t;<br>
  struct date dt;</p>
<p> getdate(&amp;dt);<br>
  gettime(&amp;t);</p>
<p> clrscr();<br>
  printf(&quot;System Date : %d/%d/%d \n&quot;, dt.da_day, dt.da_mon, dt.da_year);<br>
  printf(&quot;System Time : %u:%u:%u &quot;, t.ti_hour, t.ti_min, t.ti_sec);<br>
  getch();<br>
  }</p>
<p> </p>
<p>BIT FIELDS<br>
  C allows using bit fields to hold data items and thereby to pack several data 
  items in a word (16 bits) of memory. Bit fields allow direct manipulation of 
  a string of pre-selected bits as if it represented an integral quantity.<br>
  A bit field is a set of adjacent bits whose size can be from 1 to 16 bits in 
  length. A word (16 bits) can therefore be divided into a number of bit fields. 
  The name and size of bit fields are defined using a structure.<br>
  Syntax:<br>
  struct tag<br>
  {<br>
  data-type member-1: bit-length;<br>
  data-type member-2: bit-length;<br>
  &#8230;<br>
  &#8230;<br>
  data-type member-n: bit-length;<br>
  }</p>
<p>The data-type is either int (signed int) or unsigned int and the bit-length 
  is the number of bits used for the specified member. A signed bit field should 
  have at least 2 bits (one bit for sign). A colon must follow the member name. 
  The bit-length is decided by the range of value to be stored in that field. 
  The largest value that can be stored is 2n&#8211;1, where n is the bit-length.<br>
  Note: The programmer cannot take the address of a bit field variable. This means 
  we cannot use scanf to read values into bit fields and cannot use pointer to 
  access the bit fields. Bit field cannot be arrayed. Bit fields should be assigned 
  values that are within the range of their size. If you try to assign larger 
  values, unpredicted results will be obtained.<br>
  E.g. struct details<br>
  {<br>
  unsigned sex : 1; /* can store values 1 or 0 */<br>
  unsigned age : 7; /* can store values 0 to 127 */<br>
  unsigned m_status : 2; /* can store values 0 to 3 */<br>
  unsigned employed : 1; /* can store values 1 or 0 */<br>
  unsigned children : 3; /* can store values 0 to 7 */<br>
  } emp;<br>
  In the above example the structure variable emp consumes only two bytes in memory. 
  Once bit fields are defined, they can be referenced just like the normal structure 
  members of type integer using the member operator (dot or arrow).</p>
<p>E.g. emp.sex=1;<br>
  emp.age=34;<br>
  emp.m_status=2; /* 2 for divorced */<br>
  emp.children=3; etc.</p>
<p>Sample program</p>
<p> # include &lt;stdio.h&gt;<br>
  struct details<br>
  {<br>
  unsigned sex : 1; <br>
  unsigned age : 7; <br>
  unsigned m_status : 2; <br>
  unsigned employed : 1; <br>
  unsigned children : 3; <br>
  };</p>
<p> main()<br>
  {<br>
  struct details emp, *ptr;<br>
  int age; char sex;<br>
  clrscr();<br>
  ptr= &amp;emp;<br>
  printf(&#8220;Enter age : &#8221;);<br>
  scanf(&#8220;%d&#8221;, &amp;age);<br>
  printf(&#8220;Enter sex (m/f) : &#8220;); fflush(stdin);<br>
  scanf(&#8220;%c&#8221;, &amp;sex);<br>
  <br>
  emp.age = age;<br>
  ptr-&gt;sex = (sex ==&#8217;m&#8217;) ? 1: 0;</p>
<p> printf(&#8220;Age = %d \n&#8221;, emp.age);<br>
  printf(&#8220;Sex = %s &#8220;, (emp.sex == 1) ? &#8220;Male&#8221; : &#8220;Female&#8221; 
  );<br>
  getch();<br>
  } </p>
<p> </p>
<p>Bitwise Operators<br>
  Every single byte of data is made up of eight bits. Some of the applications 
  (like system software) may need to address and manipulate every single bit separately. 
  One of C&#8217;s powerful features is a set of bit manipulation operators, not 
  usually found in high-level languages. These permit the programmer to access 
  and manipulate individual bits within a piece (byte) of data. Bit-level manipulations 
  are used in setting a particular bit or group of bits to 1 or 0, to test a particular 
  bit is set or cleared and to perform certain numerical calculations faster. 
  A simple example is the use of a byte as a status flag, where each or groups 
  of bit(s) indicate some property like bit 0 ON equals &#8220;read-only&#8221;, 
  bit 6 ON equals &#8220;busy&#8221;, bits 1-4 represents the count of variables 
  etc.<br>
  Bitwise Operators can operate only upon ints and chars but not on floats and 
  doubles. Bits are numbered from zero onwards, increasing from right to left.<br>
  7 6 5 4 3 2 1 0<br>
  <br>
  Character</p>
<p>15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br>
  <br>
  Integer</p>
<p>The various Bitwise Operators can be classified into three categories, they 
  are:<br>
  &#8226; Bitwise Negate Operator (One&#8217;s Complement Operator)<br>
  &#8226; Bitwise Logical Operators<br>
  &#8226; Bitwise Shift Operators<br>
  One&#8217;s Complement Operator<br>
  The one&#8217;s complement operator (~) is a unary operator that causes the 
  bits of its operand to inverted so that 1 becomes 0 and 0 becomes 1. This operator 
  always precedes its operand.<br>
  E.g. x = 1001 0110 1100 1011<br>
  ~x = 0110 1001 0011 0100</p>
<p>This operator is combined with the Bitwise AND operator used to turn off a 
  particular bit. For example,<br>
  x = 8; /* 0000 0000 0000 1000 */<br>
  y = y &amp; (~x);<br>
  Would turn off the fourth bit in the variable y.</p>
<p>Since the one&#8217;s complement operator changes the number beyond recognition, 
  this operator is used in file encryption.</p>
<p># include &lt;stdio.h&gt;<br>
  main()<br>
  {<br>
  char ch;<br>
  FILE *fp;<br>
  if( (fp=fopen(&#8220;data.dat&#8221;, &#8220;w&#8221;) == NULL)<br>
  {<br>
  printf(&#8220;File creation error&#8221;);<br>
  exit(1);<br>
  }<br>
  <br>
  while( (ch=getchar())!=EOF )<br>
  fputc(~ch, fp);</p>
<p> fclose(fp);<br>
  }</p>
<p>Bitwise Logical Operators<br>
  There are three logical Bitwise operators:<br>
  &#8226; Bitwise AND (&amp;)<br>
  &#8226; Bitwise OR (|) [ Bitwise inclusive OR]<br>
  &#8226; Bitwise XOR (^) [ Bitwise exclusive OR]<br>
  Bitwise logical operators are binary operators and each of these operators requires 
  two integer type operands.<br>
  The operations are carried out independently on each pair of corresponding bits 
  within the operand. Thus, the least significant bits (i.e., rightmost bits) 
  within the two operands will be compared, then the next least significant bit 
  and so on, until all of the bits have been compared.<br>
  Bitwise AND<br>
  A single ampersand (&amp;) character represents the Bitwise AND operator. The 
  result of ANDing opera-tion is 1 if both the bits have a value of 1 (true or 
  ON); otherwise it is 0.<br>
  BIT 1 BIT 2 BIT 1 &amp; BIT 2<br>
  0 0 0<br>
  0 1 0<br>
  1 0 0<br>
  1 1 1<br>
  E.g. <br>
  x? 0000 0000 0000 1101 &amp; /* decimal 13 */<br>
  y? 0000 0000 0001 1001 /* decimal 25 */<br>
  x&amp;y? 0000 0000 0000 1001 /* decimal 9 */</p>
<p>Bitwise ANDing is used to test whether a particular bit is 1 or 0. This operator 
  is combined with the one&#8217;s complement operator used to turn off a particular 
  bit.</p>
<p>For example the following program tests whether the second bit of the variable 
  flag is 1 or 0.</p>
<p>main()<br>
  {<br>
  int flag;<br>
  test=4; /* 0000 0000 0000 0100 */</p>
<p> printf(&#8220;Enter a number : &#8220;);<br>
  scanf(%d&#8221;, &amp;flag);<br>
  <br>
  if ( (flag &amp; test) != 0)<br>
  {<br>
  printf(&#8220;The second bit of the entered number is set ( i.e., 1)&#8221;);<br>
  }<br>
  else<br>
  {<br>
  printf(&#8220;The second bit of the entered number is not set ( i.e., 0)&#8221;);<br>
  }<br>
  getch();<br>
  }</p>
<p>Q. Write a program to print the decimal number entered by the user is ODD or 
  EVEN.<br>
  [Hint: The rightmost bit of an ODD number is always set to 1]<br>
  Ans:<br>
  main()<br>
  {<br>
  int test = 1; /* 0000 0000 0000 0001 */ <br>
  int x;</p>
<p> printf(&#8220;Enter a number to test : &#8220;);<br>
  scanf(&#8220;%d&#8221;, &amp;x);</p>
<p> if( x &amp; test )<br>
  printf(&#8220; Number is ODD &#8216;);<br>
  else<br>
  printf(&#8220; Number is EVEN &#8220;);<br>
  }<br>
  Bitwise OR<br>
  The Bitwise OR is represented by the symbol | (vertical bar or pipe symbol). 
  The result of OR opera-tion is 1 if at least one of the bits has a value of 
  1 (true or ON); otherwise it is zero.<br>
  BIT 1 BIT 2 BIT 1 | BIT 2<br>
  0 0 0<br>
  0 1 1<br>
  1 0 1<br>
  1 1 1</p>
<p>E.g. <br>
  x? 0000 0000 0000 1101 | /* decimal 13 */<br>
  y? 0000 0000 0001 1001 /* decimal 25 */<br>
  x|y? 0000 0000 0001 1101 /* decimal 29 */</p>
<p>The Bitwise OR operation is often used to set a particular bit to 1. For example,</p>
<p>main()<br>
  {<br>
  int set=8; /* 0000 0000 0000 1000 */<br>
  int x;<br>
  <br>
  printf(&#8220; Enter a number : &#8220;);<br>
  scanf( &#8220; %d&#8221;, &amp;x);</p>
<p> if( (x &amp; set) ==0)<br>
  {<br>
  printf(&#8220; the third bit is not set to 1&#8221;);<br>
  x = x | set ; <br>
  if( (x &amp; set) !=0)<br>
  printf(&#8220; Now the third bit is set to 1&#8221;);<br>
  }<br>
  else<br>
  printf(&#8220; The third bit is already set to 1&#8221;);</p>
<p> getch();<br>
  }<br>
  Bitwise XOR<br>
  The Bitwise eXclusive OR is represented by the symbol ^ (caret). The result 
  of the XOR operator is 1 if only one of the bits is 1(true or ON); otherwise 
  it is zero.<br>
  BIT 1 BIT 2 BIT 1 ^ BIT 2<br>
  0 0 0<br>
  0 1 1<br>
  1 0 1<br>
  1 1 0<br>
  E.g. <br>
  x? 0000 0000 0000 1101 ^ /* decimal 13 */<br>
  y? 0000 0000 0001 1001 /* decimal 25 */<br>
  x^y? 0000 0000 0001 0100 /* decimal 22 */</p>
<p>The Bitwise XOR operator is used to toggle a bit ON or OFF. The number XORed 
  with another number twice gives the original number.</p>
<p>main()<br>
  {<br>
  int x=50;<br>
  printf(&#8220;Before any XORing, the value of x = %d\n&#8221;, x); /* this will 
  be 50 */</p>
<p> x ^= 12;<br>
  printf(&#8220;After the first XORing with 12, the value of x = %d\n&#8221;, 
  x); /* this will be 62 */<br>
  <br>
  x = x^12;<br>
  printf(&#8220;After the second XORing with 12, the value of x = %d\n&#8221;, 
  x); /* this will be 50 */<br>
  }<br>
  Bitwise Shift Operators <br>
  The shift operators are used to move bit pattern either to the left or to the 
  right and they require two operands to operate. The first one is an integer 
  type operand that represents the pattern to be shifted. The second is an unsigned 
  integer that indicates the number of displacement (i.e., the number of positions 
  to be shifted). The different shift operators are,<br>
  &#8226; Right shift operator<br>
  &#8226; Left shift operator<br>
  Right Shift Operator<br>
  The right shift operator is represented by the symbol, ??. The right shift operator 
  causes all the bits in the first operand to be shifted to the right by the number 
  of positions indicated by the second operand. The rightmost bits in the original 
  bit pattern will be lost. If the bit pattern shifted represents an un-signed 
  integer, then the leftmost bit positions that become vacant will be filled with 
  zeros. If the bit pattern representing a signed integer is shifted to the right, 
  the outcome of the shift operation may depend on the value of the leftmost bit 
  (the sign bit). Most compilers will fill the vacant bit positions with the contents 
  of this bit. Some compilers will fill the vacant bit positions with zeros regardless 
  of the sign of the original integer quantity.</p>
<p>E.g. x? 0000 0000 0000 1000 ( decimal 8 ) <br>
  x = x ?? 2;<br>
  x ? 0000 0000 0000 0010 ( decimal 2 )</p>
<p>Shifting the operand one bit to the right is same as dividing it by 2.</p>
<p>main()<br>
  {<br>
  int x=50, y=40;<br>
  printf(&#8220; x = %d \t y = %d \n&#8221;, x, y); /* will print x = 50 y = 40 
  */<br>
  x = x ?? 1;<br>
  y = y ?? 1;<br>
  printf(&#8220; x = %d \t y = %d \n&#8221;, x, y); /* will print x = 25 y = 20 
  */<br>
  x = x ?? 1;<br>
  y = y ?? 1;<br>
  printf(&#8220; x = %d \t y = %d \n&#8221;, x, y); /* will print x = 12 y = 10 
  */<br>
  }</p>
<p>Left Shift Operator<br>
  The left shift operator is represented by the symbol, ??. The left shift operator 
  causes all the bits in the first operand to be shifted to the left by the number 
  of positions indicated by the second operand. The leftmost bits in the original 
  bit pattern will be lost, then the rightmost bit positions that become vacant 
  will be filled with zeros.</p>
<p>E.g. x? 0000 0000 0000 1000 ( decimal 8 ) <br>
  x = x ?? 2;<br>
  x ? 0000 0000 0010 0000 ( decimal 32 )</p>
<p>Shifting the operand one bit to the left is same as multiplying it by 2.</p>
<p>main()<br>
  {<br>
  int x=5, y=4;<br>
  printf(&#8220; x = %d \t y = %d \n&#8221;, x, y); /* will print x = 5 y = 4 
  */<br>
  x = x ?? 1;<br>
  y = y ?? 1;<br>
  printf(&#8220; x = %d \t y = %d \n&#8221;, x, y); /* will print x = 10 y = 8 
  */<br>
  x = x ?? 1;<br>
  y = y ?? 1;<br>
  printf(&#8220; x = %d \t y = %d \n&#8221;, x, y); /* will print x = 20 y = 16 
  */<br>
  }</p>
<p><br>
  Q). Write a function to display the bit pattern of the integer accepted from 
  the user.</p>
<p>Ans:<br>
  main() tobinary(int n)<br>
  { {<br>
  int x; int bits=15,i,k,andmask;<br>
  for(i=bits; i&gt;=0; i--)<br>
  printf( &#8220; enter a Number : &#8220;); {<br>
  scanf(&#8220;%d&#8221;, &amp;x); andmask = 1 ?? i;<br>
  k = n &amp; andmask;<br>
  tobinary(x); k == 0 ? printf(&quot;0&quot;):printf(&quot;1&quot;);<br>
  }<br>
  getch(); printf(&quot;\n&quot;);<br>
  } }</p>
<p></p>
<p><br>
  Masking<br>
  Masking is a process in which a given bit pattern is transformed into another 
  bit pattern by means of a Logical Bitwise Operation. The original bit pattern 
  is one of the operand, in the bitwise operation. The second bit pattern, which 
  is a specially selected bit pattern that brings out the required transformation 
  to the original is called the mask.<br>
  Masking is used in many different ways,<br>
  &#8226; To decide (set, clear or toggle) bit pattern of an integer<br>
  &#8226; To copy a portion of a given bit pattern to a new variable, while the 
  remainder of the new variable is filled with zeros. ( using bitwise AND)<br>
  E.g. n = 0010 0100 1010 1100 &amp;<br>
  mask = 0000 0000 1111 1111<br>
  n &amp; mask = 0000 0000 1010 1100<br>
  &#8226; To copy a portion of a given bit pattern to a new variable, while the 
  remainder of the new variable is filled with ones. ( using bitwise OR)<br>
  E.g. n = 0010 0100 1010 1100 |<br>
  mask = 1111 1111 0000 0000 <br>
  n | mask = 1111 1111 1010 1100<br>
  &#8226; To copy a portion of a given bit pattern to a new variable, while the 
  remainder of the original bit pattern is inverted within the new variable. ( 
  using bitwise XOR)</p>
<p>E.g. n = 0010 0100 1010 1100 ^<br>
  mask = 1111 1111 0000 0000 <br>
  n ^ mask = 1101 1011 1010 1100</p>
<p>NOTE:<br>
  Use &amp; with mask bit = 0 to clear a bit to 0.<br>
  Use &amp; with mask bit = 1 to leave a bit unchanged.<br>
  Use | with mask bit = 1 to set a bit to 1.<br>
  Use | with mask bit = 0 to leave a bit unchanged.<br>
  Use ^ with mask bit = 1 to invert a bit.<br>
  Use ^ with mask bit = 0 to leave a bit unchanged.</p>
<p><br>
  Sample Questions<br>
  1) DOS keeps the date on which a file is created or last modified is stored 
  as a 2-byte entry in the 32-byte directory entry of that file. Thereby saving 
  the valuable 6 bytes for each file. This date is stored in a bitwise method 
  as in the following picture.</p>
<p>15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br>
  Y Y Y Y Y Y Y M M M M D D D D D<br>
  Year<br>
  Month Day </p>
<p>DOS converts the actual date into a 2-byte value using the following formula:<br>
  Date = 512 *(year &#8211; 1980) + 32 * month + day<br>
  And then stores the binary equivalent of that obtained number as a 2-byte bit 
  pattern.</p>
<p>Q) Write a program to decode the date field in directory entry using the bitwise 
  operators?<br>
  Ans:<br>
  # include &lt;stdio.h&gt;<br>
  # include &lt;dos.h&gt;<br>
  # include &lt;fcntl.h&gt;</p>
<p>main()<br>
  {<br>
  union REGS i,o;<br>
  int handle;<br>
  unsigned int d,t;<br>
  handle=open(&quot;c:\\command.com&quot;,O_BINARY);<br>
  clrscr();<br>
  i.h.al=0;<br>
  i.h.ah=0x57;<br>
  i.x.bx=handle;<br>
  int86(33,&amp;i,&amp;o);<br>
  close(handle);<br>
  printf(&quot;File name : Command.Com\n\n&quot;);<br>
  d=o.x.dx;<br>
  printf(&quot;Date in coded format : %u\n&quot;,d);<br>
  printf(&quot;Date in binary format : &quot;);</p>
<p> tobinary(d); /* YYYYYYYMMMMDDDDD */</p>
<p> printf(&quot;\nYear\t%u\n&quot;,1980+(d&gt;&gt;9) );<br>
  printf(&quot;Month\t%02u\n&quot;,((d&lt;&lt;7)&gt;&gt;12) );<br>
  printf(&quot;Day\t%02u\n&quot;,((d&lt;&lt;11)&gt;&gt;11) );</p>
<p>getch();<br>
  }</p>
<p>tobinary(unsigned int n)<br>
  {<br>
  int i,k,andmask;<br>
  for(i=15; i&gt;=0; i--)<br>
  {<br>
  andmask = 1 &lt;&lt; i;<br>
  k = n &amp; andmask;<br>
  k == 0 ? printf(&quot;0&quot;):printf(&quot;1&quot;);<br>
  }<br>
  printf(&quot;\n&quot;);<br>
  }</p>
<p>Similarly DOS uses a 2-byte bit pattern to store the time.</p>
<p>15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br>
  H H H H H M M M M M M S S S S S<br>
  Hour<br>
  Minute second </p>
<p>Q) Write a program to decode the time field in directory entry using the bitwise 
  operators?<br>
  Ans:<br>
  # include &lt;stdio.h&gt;<br>
  # include &lt;dos.h&gt;<br>
  # include &lt;fcntl.h&gt;</p>
<p>main()<br>
  {<br>
  union REGS i,o;<br>
  int handle;<br>
  unsigned int d,t;<br>
  handle=open(&quot;c:\\command.com&quot;,O_BINARY);<br>
  clrscr();<br>
  i.h.al=0;<br>
  i.h.ah=0x57;<br>
  i.x.bx=handle;<br>
  int86(33,&amp;i,&amp;o);<br>
  close(handle);<br>
  printf(&quot;File name : Command.Com\n\n&quot;);</p>
<p> t=o.x.cx;<br>
  printf(&quot;\nTime in coded format : %u\n&quot;,t);<br>
  printf(&quot;Time in binary format : &quot;);<br>
  tobinary(t); /* HHHHHMMMMMMSSSSS */</p>
<p> printf(&quot;\nHour\t%u\n&quot;, (t&gt;&gt;11) );<br>
  printf(&quot;Minute\t%u\n&quot;,((t&lt;&lt;5)&gt;&gt;10) );<br>
  printf(&quot;Second\t%u\n&quot;,((t&lt;&lt;11)&gt;&gt;11) );</p>
<p>getch();<br>
  }</p>
<p>tobinary(unsigned int n)<br>
  {<br>
  int i,k,andmask;<br>
  for(i=15; i&gt;=0; i--)<br>
  {<br>
  andmask = 1 &lt;&lt; i;<br>
  k = n &amp; andmask;<br>
  k == 0 ? printf(&quot;0&quot;):printf(&quot;1&quot;);<br>
  }<br>
  printf(&quot;\n&quot;);<br>
  }<br>
  2) DOS stores the file attributes in a single byte as shown below.</p>
<p>Bit numbers Meaning<br>
  7 6 5 4 3 2 1 0 <br>
  1 Read only<br>
  1 Hidden<br>
  1 System<br>
  1 Volume label entry<br>
  1 Sub directory entry<br>
  1 Archive bit<br>
  1 Unused<br>
  1 Unused</p>
<p>Q) Write a program to display the current attributes of any file.<br>
  Ans:<br>
  # include &lt;stdio.h&gt;<br>
  # include &lt;dos.h&gt;</p>
<p>main()<br>
  {<br>
  unsigned int x;<br>
  union REGS i,o;<br>
  struct SREGS s;<br>
  unsigned char far *file=&quot;c:\\command.com&quot;;<br>
  clrscr();<br>
  i.h.al=0;<br>
  i.h.ah=0x43;<br>
  i.x.dx=FP_OFF(file);<br>
  s.ds=FP_SEG(file);<br>
  int86x(33,&amp;i,&amp;o,&amp;s);<br>
  printf(&quot;%u\n\n&quot;,o.x.cx);<br>
  x=o.x.cx;</p>
<p> tobinary(x);</p>
<p>getch();<br>
  }</p>
<p>tobinary(unsigned int n)<br>
  {<br>
  char *arr[]={<br>
  &quot;Read Only&quot;,<br>
  &quot;Hidden File&quot;,<br>
  &quot;System File&quot;,<br>
  &quot;Volume label entry&quot;,<br>
  &quot;Sub-directory entry&quot;,<br>
  &quot;Archive bit&quot;,<br>
  &quot;Unused&quot;,<br>
  &quot;Unused&quot;<br>
  };<br>
  int i,k,andmask;<br>
  for(i=7; i&gt;=0; i--)<br>
  {<br>
  andmask = 1 &lt;&lt; i;<br>
  k = n &amp; andmask;<br>
  k == 0 ? printf(&quot;0&quot;):printf(&quot;1&quot;);<br>
  printf(&quot;\t%s\n&quot;,arr[i]);<br>
  }<br>
  printf(&quot;\n&quot;);<br>
  }</p>
<p> <br>
  Appendix A</p>
<p>TOKENS<br>
  In a C program the smallest individual units are known as C tokens. C has six 
  different types of tokens and they are KEYWORDS (like float, while etc.), IDENTIFIERS 
  (like variable names, function names etc.), CONSTANTS (integer constants, char 
  constants etc.), STRINGS (like &#8220;ABC&#8221;, &#8220;Hello&#8221; etc.), 
  SPECIAL SYMBOLS (like {, }, [, ] etc.) and OPERATORS (like +, -, *, &amp;&amp;, 
  % etc.). C programs are written using these tokens and the syntax of the language.<br>
  CONSTANTS<br>
  Constants in C refer to fixed values that do not change during the execution 
  of a program.<br>
  Integer Constants<br>
  An integer constant refers to a sequence of digits. There are three types of 
  integers.<br>
  Decimal<br>
  Decimal integers consists of a set of digits, 0 through 9, preceded by optional 
  &#8211; or + sign.<br>
  E.g. 345<br>
  -23<br>
  0<br>
  23456 etc.<br>
  Octal<br>
  Octal integer (base 8) constant consists of any combination of digits, 0 through 
  7 with leading 0.<br>
  E.g. 023<br>
  0<br>
  0987<br>
  01273 etc.<br>
  Hexadecimal<br>
  A sequence of digits preceded by 0x or 0X is considered as hexadecimal (base 
  16) integer. They may also include alphabets A through F. the letters A through 
  F represent the numbers 10 through 15.<br>
  E.g. 0X78<br>
  0x61F<br>
  0XF2f etc.</p>
<p>It is also possible to store larger integer constants by applying qualifiers 
  such as U, L and UL to the constants.</p>
<p>Unsigned integer - 564U or 564u<br>
  Unsigned long integer - 78345346UL or 78345346ul<br>
  Long integer - 56757L or 56757l<br>
  Real Constants<br>
  The real (floating-point) constants are numbers containing fractional parts.</p>
<p>E.g. 9.345<br>
  -0.98<br>
  -2.3456<br>
  .34<br>
  789.<br>
  -. 66 etc</p>
<p>Real constants can also be expressed in exponential (scientific) notation. 
  The general format is,<br>
  mantissa e exponent <br>
  The mantissa is either a real number expressed in decimal notation or an integer. 
  The exponent is an integer number with an optional plus or minus sign.</p>
<p>E.g. -1.08e5 is equivalent to -1.08 * 105 i.e., -1.08 * 10,000 i.e., -1,08,000<br>
  2.3e-3 is equivalent to 2.3 * 10-3 i.e., 2.3 / 1000 i.e., 0.0023</p>
<p>By default floating point constants are represented as double precision (double). 
  Use the suffixes f or F to force single-precision and l or L to extend double 
  precision.Character Constants<br>
  Single Character Constants<br>
  A single character constant (character constant) contains a single character 
  enclosed within a pair of single quote marks.</p>
<p>E.g. &#8216;a&#8217;, &#8216;Z&#8217;, &#8216;8&#8217;, &#8216;;&#8217;<br>
  String Constants<br>
  A string constant is a sequence of characters enclosed in double quotes.</p>
<p>E.g. &#8220;Hello Everybody&#8221;<br>
  &#8220;Lotus 1-2-3&#8221;<br>
  &#8220;23+34&#8221;<br>
  &#8220;H&#8221;</p>
<p> <br>
  APPENDIX B</p>
<p>REMOVE()<br>
  remove(filename)</p>
<p> remove deletes a file.<br>
  RENAME ()<br>
  int rename(const char *oldname,<br>
  const char *newname);</p>
<p> On successfully renaming the file, rename returns 0. On error, it returns 
  &#8211;1.<br>
  ABS()<br>
  int abs(int x);</p>
<p>Gets the absolute value of an integer<br>
  ATOF()<br>
  converts a string to a floating point</p>
<p> double atof(const char *s);</p>
<p> Returns the converted value of s or 0 if s cannot be converted.<br>
  CEIL ()<br>
  rounds up</p>
<p> double ceil(double x);</p>
<p>Returns the smallest integer greater than or equal to x<br>
  FLOOR ()<br>
  rounds down</p>
<p> double floor(double x);</p>
<p>Returns the largest integer less than or equal to x.<br>
  COS ()<br>
  cosine</p>
<p> double cos(double x);</p>
<p>x is in radians. Returns a value in the range -1 to 1.<br>
  EXP ()<br>
  calculates e to the x'th power<br>
  double exp(double x);<br>
  FABS()<br>
  absolute value of a floating-point number</p>
<p> double fabs(double x);<br>
  LABS()<br>
  long absolute value</p>
<p> long labs(long x);<br>
  FMOD()<br>
  calculates x modulo y, the remainder of x/y</p>
<p> double fmod(double x, double y);<br>
  LOG()<br>
  logarithm function ln(x)</p>
<p> double log(double x);<br>
  LOG10()<br>
  logarithm function log 10(x)</p>
<p> double log10(double x);<br>
  POW()<br>
  power function, x to the y</p>
<p> double pow(double x, double y);<br>
  SIN()<br>
  sine function</p>
<p> double sin(double x);</p>
<p> x is in radians. Returns a value in the range -1 to 1.<br>
  SQRT()<br>
  calculates square root</p>
<p> double sqrt(double x);</p>
<p> Returns the square root of x.<br>
  TAN()<br>
  tangent function</p>
<p> double tan(double x);</p>
<p> x is in radians. Returns the tangent of x.<br>
  ATOI()<br>
  Converts a string to an int</p>
<p> int atoi(const char *s);</p>
<p> Returns the converted value of the input<br>
  string. If the string cannot be converted,<br>
  the return value is 0.<br>
  ATOL()<br>
  converts a string to a long</p>
<p> long atol(const char *s);</p>
<p> Returns the converted value of the input string. If the string cannot be converted 
  the return value is 0.<br>
  ITOA()<br>
  converts an integer to a string</p>
<p> char *itoa(int value, char *string, int radix);</p>
<p>Returns a pointer to the target string.<br>
  LTOA()<br>
  converts a long to a string</p>
<p> char *ltoa(long value, char *string, int radix);</p>
<p>For a decimal representation, use radix=10.<br>
  For hexadecimal, use radix=16.<br>
  Returns a pointer to the argument string.<br>
  RAND()<br>
  random number generator</p>
<p> int rand(void);</p>
<p>Returns a random number from 0 to 32767.<br>
  RANDOMIZE()<br>
  void randomize(void);</p>
<p> Initializes the random number generator with<br>
  a random value. It uses the time function,<br>
  so you should include time.h when using<br>
  this routine.<br>
  RANDOM()<br>
  int random(int num);</p>
<p> Returns an integer between 0 and (num-1).<br>
  SYSTEM()<br>
  issues an MS-DOS command</p>
<p> int system(const char *command);</p>
<p>command can execute an internal DOS command such as DIR, a .COM or .EXE program 
  file or a .BAT batch file.<br>
  Returns zero on success, -1 on failure.<br>
  ULTOA()<br>
  converts an unsigned long to a string</p>
<p> char *ultoa(unsigned long value, char *string,<br>
  int radix);</p>
<p> Returns a pointer to string. There is no error return.<br>
  STRCAT()<br>
  appends src to dest</p>
<p> char *strcat(char *dest, const char *src);<br>
  STRCHR()<br>
  finds c in str</p>
<p> char *strchr(const char *str, int c);</p>
<p> Returns a pointer to the first occurrence of the character c in str; if c 
  does not occur in str, strchr returns NULL.<br>
  STRLEN()<br>
  gets length of s</p>
<p> size_t strlen(const char *s);</p>
<p> Returns the number of characters in s, not counting the terminating null character.<br>
  STRLWR()<br>
  converts s to all lowercase</p>
<p> char *strlwr(char *s);</p>
<p>Returns pointer to s.<br>
  STRUPR()<br>
  converts all characters in s to uppercase.</p>
<p> char *strupr(char *s);<br>
  Returns a pointer to s.<br>
  TOLOWER()<br>
  translates characters to lowercase</p>
<p> int tolower(int ch);</p>
<p>Returns the converted value of ch if it's an<br>
  uppercase character; all others are returned<br>
  unchanged.<br>
  TOUPPER()<br>
  translates characters to uppercase</p>
<p> int toupper(int ch);<br>
  Returns the converted value of ch if ch was an<br>
  lowercase character; all others are returned<br>
  unchanged.<br>
  ISALNUM()<br>
  isalnum(c) - True if c is a letter or digit.<br>
  isalpha(c) - True if c is a letter.<br>
  isdigit(c) - True if c is a digit.<br>
  iscntrl(c) - True if c is a delete character<br>
  or ordinary control character.<br>
  isascii(c) - True if c is a valid ASCII character.<br>
  isprint(c) - True if c is a printable character.<br>
  isgraph(c) - Like isprint except that the<br>
  space character is excluded.<br>
  islower(c) - True if c is a lowercase letter.<br>
  isupper(c) - True if c is an uppercase letter.<br>
  ispunct(c) - True if c is a punctuation character.<br>
  isspace(c) - True if c is a space, tab, carriage <br>
  return, newline, vertical tab, or form-feed.<br>
  isxdigit(c) - True if c is a hexadecimal.</p>
<p>SOME MORE PROGRAMMING EXAMPLES :</p>
<hr>
<p>#include &lt;iostream.h&gt;<br>
#include &lt;stdlib.h&gt;<br>
int main()<br>
<br>
<br>
{<br>
int password=12345;<br>
int boomboom ;<br>
<br>
<br>
do {<br>
cout &lt;&lt; &quot;ENTER YOUR PASSWORD.&quot; &lt;&lt; endl;<br>
cin &gt;&gt; boomboom ;<br>
if (boomboom != password)<br>
<br>
<br>
{<br>
cout &lt;&lt; &quot;access denied&quot; &lt;&lt; endl;<br>
}<br>
if (boomboom == password)<br>
<br>
<br>
{<br>
cout &lt;&lt; &quot;WELCOME&quot; &lt;&lt; endl;<br>
}<br>
} while (boomboom != password);<br>
system(&quot;PAUSE&quot;);<br>
return 0;<br>
}<br>
&nbsp;</p>
<hr>
<p><font size="5">AN ADDRESS BOOK</font></p>
<p>#include&lt;fstream.h&gt;<br>
#include&lt;conio.h&gt;<br>
#include&lt;iomanip.h&gt;<br>
#include&lt;string.h&gt;<br>
#include&lt;stdlib.h&gt;<br>
const int MAX=150;<br>
<br>
struct persons<br>
{<br>
char name[20],email[30],phone[12];<br>
char addr[80],city[20],pin[8];<br>
};<br>
<br>
class address<br>
{<br>
protected:<br>
persons pers[MAX];<br>
static int count;<br>
public:<br>
address();<br>
~address()<br>
{cout&lt;&lt;&quot;Done&quot;;}<br>
void read_disk();<br>
void write_disk();<br>
void add_address();<br>
void find_address();<br>
void find_count();<br>
// I GOT SOME OF THESE FUNCTIONS FROM VARIOUS PSC CODES //CREDITS ARE FOR 
AUTHERS OF THOSE FUNCTIONS<br>
void display_all_addresses();<br>
void display_address(persons *);<br>
void delete_address(persons *);<br>
void sort_address();<br>
void print_address(persons* , int);<br>
};<br>
<br>
int address::count=-1;<br>
<br>
address::address() // initialise all elements of class address to<br>
{ //null strings<br>
for(int i=0;i&lt;MAX;i++)<br>
{<br>
strcpy(pers[i].name,&quot;&quot;);<br>
strcpy(pers[i].email,&quot;&quot;);<br>
strcpy(pers[i].phone,&quot;&quot;);<br>
strcpy(pers[i].addr,&quot;&quot;);<br>
strcpy(pers[i].city,&quot;&quot;);<br>
strcpy(pers[i].pin,&quot;&quot;);<br>
}<br>
}<br>
<br>
void address::find_count() //after reading from disk determine the position<br>
{ //at which the first null string 'name' is encountered<br>
for(int i=0;strcmpi(pers[i].name,&quot;&quot;)!=0;i++)<br>
; //this is the 'count' of no. of addrs already present<br>
count=i-1; //in file<br>
}<br>
<br>
void address::read_disk() //read from disk if file already present<br>
{<br>
ifstream infile;<br>
infile.open(&quot;addr.adb&quot;,ios::nocreate); //if not present do not create<br>
if(infile)<br>
infile.read((char*)this,sizeof(*this));//read into array elements of<br>
} //class address<br>
<br>
void address::write_disk()<br>
{<br>
ofstream outfile;<br>
outfile.open(&quot;addr.adb&quot;);//adb stands for address data base.....my own ext<br>
if(outfile) //output all the present data into addr.dat<br>
outfile.write((char*)this,sizeof(*this));<br>
else<br>
{<br>
cout&lt;&lt;&quot;\t\t\t\t\tFATAL ERROR!\n\t\tUnable to open file \&quot; addr.adb \&quot;.\<br>
Reinstall application\n&quot;;<br>
exit(1);<br>
}<br>
outfile.close();<br>
}<br>
<br>
void address::print_address(persons *temp,int times)<br>
{<br>
ofstream destfile;<br>
destfile.open(&quot;LPT1&quot;);<br>
char ch;<br>
int i=0;<br>
for(;times!=0;times--)<br>
{<br>
for(i=0;temp-&gt;name[i]!=0;i++)<br>
destfile.put(temp-&gt;name[i]);<br>
destfile.put(',');<br>
destfile.put('\n');<br>
for(i=0;temp-&gt;addr[i]!=0;i++)<br>
destfile.put(temp-&gt;addr[i]);<br>
destfile.put(',');<br>
destfile.put('\n');<br>
for(i=0;temp-&gt;city[i]!=0;i++)<br>
destfile.put(temp-&gt;city[i]);<br>
destfile.put(',');<br>
destfile.put('\n');<br>
for(i=0;temp-&gt;pin[i]!=0;i++)<br>
destfile.put(temp-&gt;pin[i]);<br>
destfile.put('.');<br>
destfile.put('\n');<br>
char ph[]=&quot;Ph:&quot;;<br>
for(i=0;ph[i]!=0;i++)<br>
destfile.put(ph[i]);<br>
for(i=0;temp-&gt;phone[i]!=0;i++)<br>
destfile.put(temp-&gt;phone[i]);<br>
destfile.put('\n');<br>
for (i=0;i&lt;3;i++) // In case of multiple copies leave 3 lines.<br>
destfile.put('\n');<br>
}<br>
}<br>
<br>
void address::display_all_addresses()<br>
{<br>
clrscr();<br>
if(count==-1)<br>
{<br>
cout&lt;&lt;&quot;\n\n\n&quot;<br>
&lt;&lt;&quot;\t ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»\n&quot;<br>
&lt;&lt;&quot;\t º Address Book Empty! º\n&quot;<br>
&lt;&lt;&quot;\t ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼\n\n\n\t&quot;;<br>
}<br>
else<br>
{<br>
cout&lt;&lt;&quot;\n ********************* DETAILS OF ALL ADDRESS STORED 
****************\n\n&quot;;<br>
for(int i=0;i&lt;=count;i++)<br>
{<br>
cout&lt;&lt;&quot; ÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ&quot;;<br>
cout&lt;&lt;endl&lt;&lt;setw(2)&lt;&lt;i+1&lt;&lt;&quot;º Name:&quot;&lt;&lt;pers[i].name&lt;&lt;endl&lt;&lt;&quot; Í¼ Email:&quot;&lt;&lt;pers[i].email<br>
&lt;&lt;endl&lt;&lt;&quot; Phone:&quot;&lt;&lt;pers[i].phone&lt;&lt;endl&lt;&lt;&quot; Address:&quot;&lt;&lt;pers[i].addr&lt;&lt;endl<br>
&lt;&lt;&quot; City:&quot;&lt;&lt;pers[i].city&lt;&lt;endl<br>
&lt;&lt;&quot; Pin:&quot;&lt;&lt;pers[i].pin&lt;&lt;endl;<br>
<br>
if((i+1)%3==0)<br>
{<br>
cout&lt;&lt;&quot; ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ&quot;;<br>
cout&lt;&lt;&quot;\n press any key to scroll&quot;;<br>
getch();<br>
clrscr();<br>
cout&lt;&lt;&quot;\n ********************* DETAILS OF ALL ADDRESS STORED 
****************\n\n&quot;;<br>
}<br>
}<br>
cout&lt;&lt;&quot; ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ&quot;;<br>
}<br>
cout&lt;&lt;&quot;\n No. of entries :&quot;&lt;&lt;count+1&lt;&lt;&quot;\n Press any key to continue..&quot;;<br>
getch();<br>
}<br>
<br>
<br>
<br>
void address::find_address() //to find the particular addr associated<br>
{ //with a key name (names first letter), if func is 1<br>
persons* temp[20]; //function is to delete else to look up address<br>
char c[1],func; //this is done so that strncmpi could be used<br>
short int temp_count=-1; //count for the temp array<br>
int choice; //in case multiple names with the same first letter<br>
cout&lt;&lt;&quot;\n\n Enter the first letter of the first-name:&quot;;<br>
c[0]=getche(); //again to use strncmpi<br>
for(int i=0;i&lt;=MAX;i++)<br>
{<br>
if(strncmpi(pers[i].name,c,1)==0) //Here it is!<br>
temp[++temp_count]=&amp;pers[i]; //if the first letter matches store the<br>
} //particulars in a separate array of pointers<br>
if(temp_count==-1)<br>
{ //if no match found display error<br>
cout&lt;&lt;&quot;\n SEARCH UNSUCCESSFUL....Press any key to continue....&quot;;<br>
getch();<br>
return;<br>
}<br>
if(temp_count==0)<br>
choice=0; //if only one match found display it<br>
else<br>
{ //else display the list of names and get the<br>
cout&lt;&lt;&quot;\nChoose from the following names...\n&quot;; //choice of the name to be<br>
for( i=0;i&lt;=temp_count;i++) //displayed<br>
cout&lt;&lt;&quot; &quot;&lt;&lt;setw(2)&lt;&lt;i+1&lt;&lt;&quot;.&quot;&lt;&lt;temp[i]-&gt;name&lt;&lt;endl;<br>
cout&lt;&lt;&quot;Enter your choice:&quot;;<br>
cin&gt;&gt;choice;<br>
choice--; //decrement choice as the array starts from 0<br>
}<br>
display_address(temp[choice]);<br>
<br>
cout&lt;&lt;&quot; ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ &quot;;<br>
//take the choice for function to be performed<br>
do{<br>
cout&lt;&lt;&quot;\nWhat operation should be performed on the address?\n1.Delete\n\<br>
2.Print.\n 'Enter' for None\n&quot;;<br>
func=getche();<br>
}while(func!='1'&amp;&amp; func!='2' &amp;&amp; func!='\r');<br>
<br>
switch(func)<br>
{<br>
case '1': cout&lt;&lt;&quot;\n Are you sure you want to delete this entry (y/n)?&quot;;<br>
c[0]=getche();<br>
if(c[0]=='y'||c[0]=='Y')<br>
{ delete_address(temp[choice]); cout&lt;&lt;&quot;\nEntry deleted....&quot;;}<br>
else<br>
cout&lt;&lt;&quot;\n\nNo action performed...Address preserved....&quot;;<br>
break;<br>
case '2':cout&lt;&lt;&quot;Copies to be printed:&quot;;<br>
int times;<br>
cin&gt;&gt;times;<br>
char ok;<br>
do{<br>
print_address(temp[choice],times);<br>
cout&lt;&lt;&quot;Is the printout O.K.?(y/n):&quot;;<br>
ok=getche();<br>
} while(ok!='y' &amp;&amp; ok!='Y');<br>
break;<br>
}<br>
cout&lt;&lt;&quot;\nPress any key to continue..&quot;;<br>
getch();<br>
}<br>
<br>
void address::display_address(persons *temp)<br>
{<br>
cout&lt;&lt;&quot;\nThe details are as follows...\n&quot;;//finally display the details!!!!<br>
cout&lt;&lt;&quot; ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ 
\n&quot;;<br>
cout&lt;&lt;&quot; º Name:&quot;&lt;&lt;temp-&gt;name&lt;&lt;endl&lt;&lt;&quot; º E-mail:&quot;&lt;&lt;temp-&gt;email<br>
&lt;&lt;endl&lt;&lt;&quot; º Phone:&quot;&lt;&lt;temp-&gt;phone&lt;&lt;endl&lt;&lt;&quot; º Address:&quot;&lt;&lt;temp-&gt;addr&lt;&lt;endl<br>
&lt;&lt;&quot; º City:&quot;&lt;&lt;temp-&gt;city&lt;&lt;endl<br>
&lt;&lt;&quot; º Pin:&quot;&lt;&lt;temp-&gt;pin&lt;&lt;endl;<br>
}<br>
<br>
void address::delete_address(persons *node)<br>
{<br>
persons *temp=&amp;pers[count--];<br>
//copy the last element's data to that to be deleted<br>
strcpy(node-&gt;name,temp-&gt;name);strcpy(node-&gt;email,temp-&gt;email);<br>
strcpy(node-&gt;phone,temp-&gt;phone);strcpy(node-&gt;addr,temp-&gt;addr);<br>
strcpy(node-&gt;city,temp-&gt;city);strcpy(node-&gt;pin,temp-&gt;pin);<br>
//now clear all the fields of pers[count]<br>
strcpy(temp-&gt;name,&quot;&quot;);strcpy(temp-&gt;email,&quot;&quot;);<br>
strcpy(temp-&gt;phone,&quot;&quot;);strcpy(temp-&gt;addr,&quot;&quot;);<br>
strcpy(temp-&gt;city,&quot;&quot;);strcpy(temp-&gt;pin,&quot;&quot;);<br>
}<br>
<br>
void address::add_address()<br>
{<br>
if(count==MAX-1)<br>
{<br>
cout&lt;&lt;&quot;\n\n Address Book is full,no more entries can be saved.\n&quot;;<br>
return;<br>
}<br>
cout&lt;&lt;&quot;\n Enter the details below (WITHOUT SPACES).\n&quot;<br>
&lt;&lt;&quot; Name:&quot;;<br>
cin&gt;&gt;pers[++count].name;cout&lt;&lt;&quot; E-mail:&quot;;<br>
cin&gt;&gt;pers[count].email; cout&lt;&lt;&quot; Phone:&quot;;<br>
cin&gt;&gt;pers[count].phone; cout&lt;&lt;&quot;Address:&quot;;<br>
cin&gt;&gt;pers[count].addr; cout&lt;&lt;&quot; State:&quot;;<br>
cin&gt;&gt;pers[count].city; cout&lt;&lt;&quot; Pin:&quot;;<br>
cin&gt;&gt;pers[count].pin;<br>
cout&lt;&lt;&quot; Details successfully added.\n\n&quot;;<br>
}<br>
<br>
void address::sort_address()//sort using simple insertion as it is highly<br>
{ //efficient for an almost sorted array<br>
persons temp; //the array will be not sorted only the first time<br>
for(int i=1;i&lt;=count;i++) //the program is run ,there-after the arry will be<br>
{ //almost sorted.<br>
temp=pers[i];<br>
for(int j=i-1;j&gt;=0 &amp;&amp; (strcmpi(temp.name,pers[j].name)&lt;0);j--)<br>
pers[j+1]=pers[j];<br>
pers[j+1]=temp;<br>
}<br>
}<br>
<br>
<br>
void main()<br>
{<br>
clrscr();<br>
cout&lt;&lt;&quot;\n\n\n&quot;;<br>
cout&lt;&lt;&quot;ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»\n&quot;;<br>
cout&lt;&lt;&quot;º'My Address Book º\n&quot;;<br>
cout&lt;&lt;&quot;ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼\n&quot;;<br>
address book;<br>
book.read_disk();<br>
book.find_count(); //as soon as the file is read call find_count to<br>
char c; // assign value to count so that new addresses can be inserted<br>
while(1)<br>
{<br>
cout&lt;&lt;&quot;\n\n 1.Enter new address.\n \<br>
2.Look up an address.\n 3.View all addresses.(Press ESC to quit)\n &quot;;<br>
c=getche();<br>
switch(c)<br>
{<br>
case '1':book.add_address();<br>
book.write_disk(); //save info to disk for safety in case of<br>
break; //power failure or &quot;you being lazy&quot;!<br>
case '2':clrscr();<br>
book.find_address(); //pass 1 if function selected is delete<br>
clrscr();<br>
break;<br>
case '3':book.display_all_addresses();<br>
clrscr();<br>
break;<br>
case 27:putch('\b');<br>
book.sort_address(); //sort it just before exit ....again..<br>
book.write_disk(); //for efficiency sake<br>
cout&lt;&lt;&quot;Saving all data.........done.\n Exiting...&quot;;<br>
return;<br>
default:cout&lt;&lt;&quot;\n Entry Error!\n\t&quot;;<br>
}<br>
}<br>
}<br>
&nbsp;</p>
<hr>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
THANKS FOR ALL THOSE REFERENCE MATERIALS I GOT FROM MY SCHOOL LIBRARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;</p>
    </td>
    <td style="border-style: none; border-width: medium" width="14" height="116" bgcolor="#FFFFCC">&nbsp;</td>
  </tr>
  <tr>
    <td style="border-style: none; border-width: medium" width="9" height="11" bgcolor="#009900">&nbsp;</td>
    <td style="border-style: none; border-width: medium" width="795" height="11" bgcolor="#009900">&nbsp;</td>
    <td style="border-style: none; border-width: medium" width="14" height="11" bgcolor="#009900">&nbsp;</td>
  </tr>
  </table>

</body>

</html>